# 第四章 多线程编

## 线程和进程

### 进程

计算机程序只是存储在磁盘上的可执行二进制(或其他类型)文件。只有把它们加载到 内存中并被操作系统调用，才拥有其生命期。进程(有时称为重量级进程)则是一个执行中 的程序。每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。 操作系统管理其上所有进程的执行，并为这些进程合理地分配时间。进程也可以通过派生
(fork 或 spawn)新的进程来执行其他任务，不过因为每个新进程也都拥有自己的内存和数据 栈等，所以只能采用进程间通信(IPC)的方式共享信息。

### 线程

线程(有时候称为轻量级进程)与进程类似，不过它们是在同一个进程下执行的，并 共享相同的上下文。可以将它们认为是在一个主进程或“主线程”中并行运行的一些“迷 你进程”。

线程包括开始、执行顺序和结束三部分。它有一个指令指针，用于记录当前运行的上下 文。当其他线程运行时，它可以被抢占(中断)和临时挂起(也称为睡眠)——这种做法叫 做让步(yielding)。

一个进程中的各个线程与主线程共享同一片数据空间，因此相比于独立的进程而言，线 程间的信息共享和通信更加容易。线程一般是以并发方式执行的，正是由于这种并行和数据 共享机制，使得多任务间的协作成为可能。当然，在单核 CPU 系统中，因为真正的并发是不 可能的，所以线程的执行实际上是这样规划的:每个线程运行一小会儿，然后让步给其他线 程(再次排队等待更多的 CPU 时间)。在整个进程的执行过程中，每个线程执行它自己特定 的任务，在必要时和其他线程进行结果通信。

当然，这种共享并不是没有风险的。如果两个或多个线程访问同一片数据，由于数据访 问顺序不同，可能导致结果不一致。这种情况通常称为竞态条件(race condition)。幸运的是， 大多数线程库都有一些同步原语，以允许线程管理器控制执行和访问。

另一个需要注意的问题是，线程无法给予公平的执行时间。这是因为一些函数会在完成 前保持阻塞状态，如果没有专门为多线程情况进行修改，会导致 CPU 的时间分配向这些贪婪 的函数倾斜。

## 线程和 Python

### 全局解释器锁

Python 代码的执行是由 Python 虚拟机(又名解释器主循环)进行控制的。Python 在 设计时是这样考虑的，在主循环中同时只能有一个控制线程在执行，就像单核 CPU 系统 中的多进程一样。内存中可以有许多程序，但是在任意给定时刻只能有一个程序在运行。 同理，尽管 Python 解释器中可以运行多个线程，但是在任意给定时刻只有一个线程会被 解释器执行。

对 Python 虚拟机的访问是由全局解释器锁(GIL)控制的。这个锁就是用来保证同时只 能有一个线程运行的。在多线程环境中，Python 虚拟机将按照下面所述的方式执行

1) 设置 GIL。
2) 切换进一个线程去运行。 
3) 执行下面操作之一。
    a) 指定数量的字节码指令。
    b) 线程主动让出控制权(可以调用 time.sleep(0)来完成)。 
4) 把线程设置回睡眠状态(切换出线程)。
5) 解锁 GIL。
6) 重复上述步骤。


当调用外部代码(即，任意 C/C++扩展的内置函数)时，GIL 会保持锁定，直至函数执 行结束(因为在这期间没有 Python 字节码计数)。编写扩展函数的程序员有能力解锁 GIL， 然而，作为 Python 开发者，你并不需要担心 Python 代码会在这些情况下被锁住。

例如，对于任意面向 I/O 的 Python 例程(调用了内置的操作系统 C 代码的那种)， GIL 会在 I/O 调用前被释放，以允许其他线程在 I/O 执行的时候运行。而对于那些没有太 多 I/O 操作的代码而言，更倾向于在该线程整个时间片内始终占有处理器(和 GIL)。换 句话说就是，I/O 密集型的 Python 程序要比计算密集型的代码能够更好地利用多线程 环境。

如果你对源代码、解释器主循环和 GIL 感兴趣，可以看看 Python/ceval.c 文件。

### 退出线程

当一个线程完成函数的执行时，它就会退出。另外，还可以通过调用诸如 thread.exit()之 类的退出函数，或者 sys.exit()之类的退出 Python 进程的标准方法，亦或者抛出 SystemExit 异常，来使线程退出。不过，你不能直接“终止”一个线程。

下一节将会详细讨论两个与线程相关的 Python 模块，不过在这两个模块中，不建议使用 thread 模块。给出这个建议有很多原因，其中最明显的一个原因是在主线程退出之后，所有 其他线程都会在没有清理的情况下直接退出。而另一个模块 threading 会确保在所有“重要的” 子线程退出前，保持整个进程的存活(对于“重要的”这个含义的说明，请阅读下面的核心 提示:“避免使用 thread 模块”)。

而主线程应该做一个好的管理者，负责了解每个单独的线程需要执行什么，每个派生的 线程需要哪些数据或参数，这些线程执行完成后会提供什么结果。这样，主线程就可以收集 每个线程的结果，然后汇总成一个有意义的最终结果。

### 在 Python 中使用线程

Python 虽然支持多线程编程，但是还需要取决于它所运行的操作系统。如下操作系统是 支持多线程的:绝大多数类 UNIX 平台(如 Linux、Solaris、Mac OS X、*BSD 等)，以及 Windows 平台。Python 使用兼容 POSIX 的线程，也就是众所周知的 pthread。

默认情况下，从源码构建的 Python(2.0 及以上版本)或者 Win32 二进制安装的 Python， 线程支持是已经启用的。要确定你的解释器是否支持线程，只需要从交互式解释器中尝试导 入 thread 模块即可，如下所示(如果线程是可用的，则不会产生错误)。

>>> import thread 
>>>

如果你的 Python 解释器没有将线程支持编译进去，模块导入将会失败。

>>> import thread
Traceback (innermost last):
File "<stdin>", line 1, in ? 
ImportError: No module named thread

这种情况下，你可能需要重新编译你的 Python 解释器才能够使用线程。一般可以在调用 configure 脚本的时候使用--with-thread 选项。查阅你所使用的发行版本的 README 文件，来 获取如何在你的系统中编译线程支持的 Python 的指定指令。

***

### 不使用线程的情况

在第一个例子中，我们将使用 time.sleep()函数来演示线程是如何工作的。time.sleep()函数需要一个浮点型的参数，然后以这个给定的秒数进行“睡眠”，也就是说，程序的执行会暂 时停止指定的时间。

创建两个时间循环:一个睡眠 4 秒(loop0());另一个睡眠 2 秒(loop1())(这里使用“loop0” 和“loop1”作为函数名，暗示我们最终会有一个循环序列)。如果在一个单进程或单线程的 程序中顺序执行 loop0()和 loop1()，就会像示例 4-1 中的 onethr.py 一样，整个执行时间至少会 达到 6 秒钟。而在启动 loop0()和 loop1()以及执行其他代码时，也有可能存在 1 秒的开销，使 得整个时间达到 7 秒。

现在，假设 loop0()和 loop1()中的操作不是睡眠，而是执行独立计算操作的函数，所有结 果汇总成一个最终结果。那么，让它们并行执行来减少总的执行时间是不是有用的呢?这就 是现在要介绍的多线程编程的前提。

### Python 的 threading 模块

Python 提供了多个模块来支持多线程编程，包括 thread、threading 和 Queue 模块等。程 序是可以使用 thread 和 threading 模块来创建与管理线程。thread 模块提供了基本的线程和锁 定支持;而 threading 模块提供了更高级别、功能更全面的线程管理。使用 Queue 模块，用户 可以创建一个队列数据结构，用于在多线程之间进行共享。我们将分别来查看这几个模块， 并给出几个例子和中等规模的应用。

***

## thread 模块

让我们先来看看 thread 模块提供了什么。除了派生线程外，thread 模块还提供了基本的 同步数据结构，称为锁对象(lock object，也叫原语锁、简单锁、互斥锁、互斥和二进制信号 量)。如前所述，这个同步原语和线程管理是密切相关的。

表 4-1 列出了一些常用的线程函数，以及 LockType 锁对象的方法。

----|----
函数/方法|描述
thread 模块的函数|
start_new_thread (function, args, kwargs=None)|派生一个新的线程，使用给定的 args 和可选的 kwargs 来执行 function
allocate_lock()|分配 LockType 锁对象
exit()|给线程退出指令
LockType 锁对象的方法|
acquire (wait=None)|尝试获取锁对象
locked ()|如果获取了锁对象则返回 True，否则，返回 False
release ()|释放锁

thread 模块的核心函数是 start_new_thread()。它的参数包括函数(对象)、函数的参数以 及可选的关键字参数。将专门派生新的线程来调用这个函数。

把多线程整合进 onethr.py 这个例子中。把对 loop*()函数的调用稍微改变一下，得到示例 4-2 中的 mtsleepA.py 文件。

## threading 模块

现在介绍更高级别的 threading 模块。除了 Thread 类以外，该模块还包括许多非常好用
的同步机制。表 4-2 给出了 threading 模块中所有可用对象的列表。

表 4-2 threading 模块的对象

----|----
对象|描述

Thread|表示一个执行线程的对象

Lock|锁原语对象(和 thread 模块中的锁一样)

RLock|可重入锁对象，使单一线程可以(再次)获得已持有的锁(递归锁)

Condition|条件变量对象，使得一个线程等待另一个线程满足特定的“条件”，比如改变状态或 某个数据值

Event|条件变量的通用版本，任意数量的线程等待某个事件的发生，在该事件发生后所有 线程将被激活

Semaphore|为线程间共享的有限资源提供了一个“计数器”，如果没有可用资源时会被阻塞

BoundedSemaphore|与 Semaphore 相似，不过它不允许超过初始值

Timer|与 Thread 相似，不过它要在运行前等待一段时间

Barrier|创建一个“障碍”，必须达到指定数量的线程后才可以继续

本节将研究如何使用 Thread 类来实现多线程。由于之前已经介绍过锁的基本概念，因此 这里不会再对锁原语进行介绍。因为 Thread()类同样包含某种同步机制，所以锁原语的显式 使用不再是必需的了。

```
核心提示：守护线程(daemon)

避免使用 thread 模块的另一个原因是该模块不支持守护线程这个概念。当主线程退出 时，所有子线程都将终止，不管它们是否仍在工作。如果你不希望发生这种行为，就要引 入守护线程的概念了。

threading 模块支持守护线程，其工作方式是:守护线程一般是一个等待客户端请 求服务的服务器。如果没有客户端请求，守护线程就是空闲的。如果把一个线程设置 为守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成。 如同在第 2 章中看到的那样，服务器线程远行在一个无限循环里，并且在正常情况下 不会退出

如果主线程准备退出时，不需要等待某些子线程完成，就可以为这些子线程设置守护 线程标记。该标记值为真时，表示该线程是不重要的，或者说该线程只是用来等待客户端 请求而不做任何其他事情。

要将一个线程设置为守护线程，需要在启动线程之前执行如下赋值语句: thread.daemon = True(调用 thread.setDaemon(True)的旧方法已经弃用了)。同样，要检 查线程的守护状态，也只需要检查这个值即可(对比过去调用 thread.isDaemon()的方 法)。一个新的子线程会继承父线程的守护标记。整个 Python 程序(可以解读为:主线 程)将在所有非守护线程退出之后才退出，换句话说，就是没有剩下存活的非守护线 程时。
```

### Thread 类

threading 模块的 Thread 类是主要的执行对象。它有 thread 模块中没有的很多函数。

表 4-3 Thread 对象的属性和方法

----|----
属性|描述

Thread 对象数据属性|
name|线程名

ident|线程的标识符

daemon|布尔标志，表示这个线程是否是守护线程

Thread 对象方法|

_init_(group=None, tatget=None, name=None, args=(), kwargs ={}, verbose=None, daemon=None) |实例化一个线程对象，需要有一个可调用的 target，以及其参数 args 或 kwargs。还可以传递 name 或 group 参数，不过后者还未实现。此 外，verbose 标志也是可接受的。而 daemon 的值将会设定 thread.daemon 属性/标志

start()|开始执行该线程

run()|定义线程功能的方法(通常在子类中被应用开发者重写)

join (timeout=None)|直至启动的线程终止之前一直挂起;除非给出了 timeout(秒)，否则 会一直阻塞

getName()|返回线程名

setName (name)|设定线程名

isAlivel /is_alive ()|布尔标志，表示这个线程是否还存活

isDaemon()|如果是守护线程，则返回 True;否则，返回 False

setDaemon(daemonic)|把线程的守护标志设定为布尔值 daemonic(必须在线程 start()之前 调用)


***

生产者-消费者问题和 Queue/queue 模块

最后一个例子演示了生产者-消费者模型这个场景。在这个场景下，商品或服务的生产者 生产商品，然后将其放到类似队列的数据结构中。生产商品的时间是不确定的，同样消费者 消费生产者生产的商品的时间也是不确定的。

我们使用 Queue 模块(Python 2.x 版本，在 Python 3.x 版本中重命名为 queue)来提供线 程间通信的机制，从而让线程之间可以互相分享数据。具体而言，就是创建一个队列，让生 产者(线程)在其中放入新的商品，而消费者(线程)消费这些商品。表 4-5 列举了这个模 块中的一些属性。

表 4-5 Queue/queue 模块常用属性
----|----
属性|描述

Queue/queue 模块的类|
Queue(maxsize=0)|创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞;否则(没 有指定最大值)，为无限队列

LifoQueue(maxsize=0)|创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞;否则(没 有指定最大值)，为无限队列

PriorityQueue(maxsize=0)|创建一个优先级队列。如果给定最大值，则在队列没有空间时阻塞，否则(没
		         有指定最大值),为无限队列

Queue/queue 异常|
Empty|当对空队列调用 get*()方法时抛出异常
Full|当对已满的队列调用 put*()方法时抛出异常

Queue/queue 对象方法|
qsize ()|返回队列大小(由于返回时队列大小可能被其他线程修改，所以该值为近似值)

empty()|如果队列为空，则返回 True;否则，返回 False

full()|如果队列已满，则返回 True;否则，返回 False

put (item, block=Ture, timeout=None)|将 item 放入队列。如果 block 为 True(默认)且 timeout 为 None，则在有可用 空间之前阻塞;
                                     如果timeout为正值，则最多阻塞timeout秒;如果 block为False， 则抛出 Empty 异常

put_nowait(item)|和 put(item, False)相同

get (block=True, timeout=None)|从队列中取得元素。如果给定了 block(非 0)，则一直阻塞到有可用的元素为止

get_nowait()|和 get(False)相同

task_done()|用于表示队列中的某个元素已执行完成，该方法会被下面的 join()使用

join()|在队列中所有元素执行完毕并调用上面的 task_done()信号之前，保持阻塞

***

## 线程的替代方案

在开始编写多线程应用之前，先做一个快速回顾:通常来说，多线程是一个好东西。不过，由于 Python 的 GIL 的限制，多线程更适合于 I/O 密集型应用(I/O 释放了 GIL，可以允 许更多的并发)，而不是计算密集型应用。对于后一种情况而言，为了实现更好的并行性，你 需要使用多进程，以便让 CPU 的其他内核来执行。

这里将不再进行详细介绍(这个主题内已经在 Core Python Programming 或 Core Python Language Fundamentals 的“执行环境”章节中有所涵盖)，对于多线程或多进程而言，threading 模块的主要替代品包括以下几个。

* subprocess 模块

这是派生进程的主要替代方案，可以单纯地执行任务，或者通过标准文件(stdin、stdout、
stderr)进行进程间通信。该模块自 Python 2.4 版本起引入。

* multiprocessing 模块

该模块自 Python 2.6 版本起引入，允许为多核或多 CPU 派生进程，其接口与 threading 模块非常相似。该模块同样也包括在共享任务的进程间传输数据的多种方式。

* concurrent.futures 模块


这是一个新的高级库，它只在“任务”级别进行操作，也就是说，你不再需要过分关注 同步和线程/进程的管理了。你只需要指定一个给定了“worker”数量的线程/进程池，提交任 务，然后整理结果。该模块自 Python 3.2 版本起引入，不过有一个 Python 2.6+可使用的移植 版本，其网址为 http://code.google.com/p/pythonfutures。

使用该模块重写后 bookrank3.py 会是什么样子呢?假定代码的其他部分保持不变，下面 的代码是新模块的导入以及对_main()函数的修改。

```
from concurrent.futures import ThreadPoolExecutor

def _main():
    print('At', ctime(), 'on Amazon...') 
    with ThreadPoolExecutor(3) as executor:
        for isbn in ISBNs: 
            executor.submit(_showRanking, isbn)
    print('all DONE at:', ctime())

```

传递给concurrent.futures.ThreadPoolExecutor的参数是线程池的大小，在这个应用里就是 指要查阅排名的 3 本书。当然，这是个 I/O 密集型应用，因此多线程更有用。而对于计算密 集型应用而言，可以使用 concurrent.futures.ProcessPoolExecutor 来代替。

当我们得到执行器(无论线程还是进程)之后，它负责调度任务和整理结果，就可以调 用它的 submit()方法，来执行之前需要派生线程才能运行的那些操作了。

如果我们做一个到Python 3的完全移植，方法是将字符串格式化操作符替换为str.format() 方法，自由利用 with 语句，并使用执行器的 map()方法，那么我们完全可以删除_showRanking() 函数并将其功能混入_main()函数中。示例 4-13 的 bookrank3CF.py 是该脚本的最终版本。


