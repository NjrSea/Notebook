# 第二章 网络编程

***

## 客户端/服务器架构

### 硬件客户端/服务器架构

打印(打印机)服务器是硬件服务器的一个例子。它们处理传入的打印作业并将其发送 给系统中的打印机(或其他的打印设备)。这样的计算机通常可以通过网络进行访问，并且客
户端计算机将向它发送打印请求。

硬件服务器的另一个例子就是文件服务器。这些通常都是拥有庞大通用存储容量的计算
机，可以被客户端远程访问。客户端计算机会挂载服务器计算机上的磁盘，看起来好像这个 磁盘就在本地计算机上一样。支持文件服务器的一个最流行的网络操作系统就是 Sun 公司的 网络文件系统(NFS)。如果你正在访问一个网络磁盘驱动器，并且无法分辨它是在本地还是 网络上，那么此时客户端/服务器系统就已经完成了它的任务。它的目标就是让用户得到与访 问本地磁盘完全相同的体验，抽象起来就是正常的磁盘访问，而这些都是通过编程实现来确 保以这种方式进行。

### 软件客户端/服务器架构

现在一个更常见的软件服务器就是 Web 服务器。如果个人或公司想要运行自己的 Web 服务 器，那么必须拥有一台或多台计算机，在上面安装希望提供给用户的 Web 页面和 Web 应用程序， 然后启动 Web 服务器。一个这样的服务器的工作就是接受客户端请求，并向(Web)客户端(即 用户计算机上的浏览器)回送 Web 页面，然后等待下一个客户端的请求。这些服务器一旦开启， 都将可能永远运行。虽然它们并不能实现这一目标，但是它们会尽可能长时间地运行，除非受到 一些外力驱使才会停止，如显式地关闭，或灾难性地关闭(由于硬件故障)。
数据库服务器是另一种类型的软件服务器。它们接受客户端的存储或检索请求，响应请 求，然后等待更多的事务。与 Web 服务器类似，它们也是永远运行的。

***

### 套接字

套接字是计算机网络数据结构，它体现了上节中所描述的“通信端点”的概念。在任何 类型的通信开始之前，网络应用程序必须创建套接字。可以将它们比作电话插孔，没有它将 无法进行通信。

套接字的起源可以追溯到 20 世纪 70 年代，它是加利福尼亚大学的伯克利版本 UNIX(称 为 BSD UNIX)的一部分。因此，有时你可能会听过将套接字称为伯克利套接字或 BSD 套接 字。套接字最初是为同一主机上的应用程序所创建，使得主机上运行的一个程序(又名一个 进程)与另一个运行的程序进行通信。这就是所谓的进程间通信(Inter Process Communication， IPC)。有两种类型的套接字:基于文件的和面向网络的。

UNIX 套接字是我们所讲的套接字的第一个家族，并且拥有一个“家族名字”AF_UNIX (又名AF_LOCAL，在POSIX1.g标准中指定)，它代表地址家族(address family):UNIX。 包括 Python 在内的大多数受欢迎的平台都使用术语地址家族及其缩写 AF;其他比较旧的系 统可能会将地址家族表示成域(domain)或协议家族(protocol family)，并使用其缩写 PF 而 非 AF。类似地，AF_LOCAL(在 2000~2001 年标准化)将代替 AF_UNIX。然而，考虑到 后向兼容性，很多系统都同时使用二者，只是对同一个常数使用不同的别名。Python 本身仍
然在使用 AF_UNIX。

因为两个进程运行在同一台计算机上，所以这些套接字都是基于文件的，这意味着文件 系统支持它们的底层基础结构。这是能够说得通的，因为文件系统是一个运行在同一主机上 的多个进程之间的共享常量。

第二种类型的套接字是基于网络的，它也有自己的家族名字 AF_INET，或者地址家族: 因特网。另一个地址家族 AF_INET6 用于第 6 版因特网协议(IPv6)寻址。此外，还有其他 的地址家族，这些要么是专业的、过时的、很少使用的，要么是仍未实现的。在所有的地址 家族之中，目前 AF_INET 是使用得最广泛的

Python 2.5 中引入了对特殊类型的 Linux 套接字的支持。套接字的 AF_NETLINK 家族(无 连接[见 2.3.3 节])允许使用标准的 BSD 套接字接口进行用户级别和内核级别代码之间的 IPC。 之前那种解决方案比较麻烦，而这个解决方案可以看作一种比前一种更加优雅且风险更低的 解决方案，例如，添加新系统调用、/proc 支持，或者对一个操作系统的“IOCTL”。
针对Linux的另一种特性(Python 2.6中新增)就是支持透明的进程间通信(TIPC)协 议。TIPC 允许计算机集群之中的机器相互通信，而无须使用基于 IP 的寻址方式。Python 对 TIPC 的支持以 AF_TIPC 家族的方式呈现。
总的来说，Python 只支持 AF_UNIX、AF_NETLINK、AF_TIPC 和 AF_INET 家族。因为 本章重点讨论网络编程，所以在本章剩余的大部分内容中，我们将使用 AF_INET。

### 套接字地址:主机-端口对

如果一个套接字像一个电话插孔——允许通信的一些基础设施，那么主机名和端口号就 像区号和电话号码的组合。然而，拥有硬件和通信的能力本身并没有任何好处，除非你知道 电话打给谁以及如何拨打电话。一个网络地址由主机名和端口号对组成，而这是网络通信所 需要的。此外，并未事先说明必须有其他人在另一端接听;否则，你将听到这个熟悉的声音
“对不起，您所拨打的电话是空号，请核对后再拨”。你可能已经在浏览网页的过程中见过一 个网络类比，例如“无法连接服务器，服务器没有响应或者服务器不可达。”
有效的端口号范围为 0~65535(尽管小于 1024 的端口号预留给了系统)。如果你正在使 用 POSIX 兼容系统(如 Linux、Mac OS X 等)，那么可以在/etc/services 文件中找到预留端口 号的列表(以及服务器/协议和套接字类型)。众所周知的端口号列表可以在这个网站中查看: http://www.iana.org/assignments/port-numbers。

### 面向连接的套接字与无连接的套接字

*** 1.面向连接的套接字***

不管你采用的是哪种地址家族，都有两种不同风格的套接字连接。第一种是面向连接的， 这意味着在进行通信之前必须先建立一个连接，例如，使用电话系统给一个朋友打电话。这 种类型的通信也称为虚拟电路或流套接字。

面向连接的通信提供序列化的、可靠的和不重复的数据交付，而没有记录边界。这基本 上意味着每条消息可以拆分成多个片段，并且每一条消息片段都确保能够到达目的地，然后 将它们按顺序组合在一起，最后将完整消息传递给正在等待的应用程序

实现这种连接类型的主要协议是传输控制协议(更为人熟知的是它的缩写 TCP)。为 了 创建 TCP 套接字，必须使用 SOCK_STREAM 作为套接字类型。TCP 套接字的名字 SOCK_STREAM 基于流套接字的其中一种表示。因为这些套接字(AF_INET)的网络版本 使用因特网协议(IP)来搜寻网络中的主机，所以整个系统通常结合这两种协议(TCP 和 IP) 来进行(当然，也可以使用 TCP 和本地[非网络的 AF_LOCAL/AF_UNIX]套接字，但是很明 显此时并没有使用 IP)。

*** 2.无连接的套接字***

与虚拟电路形成鲜明对比的是数据报类型的套接字，它是一种无连接的套接字。这意味 着，在通信开始之前并不需要建立连接。此时，在数据传输过程中并无法保证它的顺序性、 可靠性或重复性。然而，数据报确实保存了记录边界，这就意味着消息是以整体发送的，而 并非首先分成多个片段，例如，使用面向连接的协议。

使用数据报的消息传输可以比作邮政服务。信件和包裹或许并不能以发送顺序到达。 事实上，它们可能不会到达。为了将其添加到并发通信中，在网络中甚至有可能存在重复 的消息。

既然有这么多副作用，为什么还使用数据报呢(使用流套接字肯定有一些优势)?由于面 向连接的套接字所提供的保证，因此它们的设置以及对虚拟电路连接的维护需要大量的开销。 然而，数据报不需要这些开销，即它的成本更加“低廉”。因此，它们通常能提供更好的性能， 并且可能适合一些类型的应用程序。

实现这种连接类型的主要协议是用户数据报协议(更为人熟知的是其缩写 UDP)。为 了 创建 UDP 套接字，必须使用 SOCK_DGRAM 作为套接字类型。你可能知道，UDP 套接字的 SOCK_DGRAM 名字来自于单词“datagram”(数据报)。因为这些套接字也使用因特网协议 来寻找网络中的主机，所以这个系统也有一个更加普通的名字，即这两种协议(UDP 和 IP) 的组合名字，或 UDP/IP。

***

## Python 中的网络编程

### socket() 模块函数

要创建套接字，必须使用 socket.socket()函数，它一般的语法如下。

```
socket(socket_family, socket_type, protocol=0)
```

其中，socket_family 是 AF_UNIX 或 AF_INET(如前所述)，socket_type 是 SOCK_STREAM 或 SOCK_DGRAM(也如前所述)。protocol 通常省略，默认为 0。

所以，为了创建 TCP/IP 套接字，可以用下面的方式调用 socket.socket()。

```
tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

同样，为了创建 UDP/IP 套接字，需要执行以下语句。

udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

因为有很多 socket 模块属性，所以此时使用“from module import *”这种导入方式可以 接受，不过这只是其中的一个例外。如果使用“from socket import *”，那么我们就把 socket 属性引入到了命名空间中。虽然这看起来有些麻烦，但是通过这种方式将能够大大缩短代码， 正如下面所示。

tcpSock = socket(AF_INET, SOCK_STREAM)

一旦有了一个套接字对象，那么使用套接字对象的方法将可以进行进一步的交互。

### 套接字对象(内置)方法

表 2-1 列出了最常见的套接字方法。在下一节中，我们将使用其中的一些方法创建 TCP 和 UDP 客户端与服务器。虽然我们专注于网络套接字，但这些方法与使用本地/不联网的套 接字时有类似的含义。

表 2-1 常见的套接字对象方法和属性

---|---
名称|描述
s.bind()|将地址(主机名、端口号对)绑定到套接字上
s.listen()|设置并启动 TCP 监听器
s.accept()|被动接受 TCP 客户端连接，一直等待直到连接到达(阻塞)

s.connect()|主动发起 TCP 服务器连接
s.connect_ex()|connect()的扩展版本，此时会以错误码的形式返回问题，而不是抛出一个异常

s.recv()|接收 TCP 消息
s.recv_into()|接收 TCP 消息到指定的缓冲区
s.send()|发送 TCP 消息
s.sendall()|完整地发送 TCP 消息
s.recvfrom()|接收 UDP 消息
s.recvfrom_into()|接收 UDP 消息到指定的缓冲区
s.sendto()|发送 UDP 消息
s.getpeername()|连接到套接字(TCP)的远程地址
s.getsockname()|当前套接字的地址
s.getsockopt()|返回给定套接字选项的值
s.setsockopt()|设置给定套接字选项的值
s.shutdown()|关闭连接
s.close()|关闭套接字
s.detach()|在未关闭文件描述符的情况下关闭套接字，返回文件描述符
s.ioctl()|控制套接字的模式(仅支持 Windows)

s.setblocking()|设置套接字的阻塞或非阻塞模式
s.settimeout()|设置阻塞套接字操作的超时时间
s.gettimeout()|获取阻塞套接字操作的超时时间

s.fileno()|套接字的文件描述符
s.makefile()|创建与套接字关联的文件对象

s.family|套接字家族
s.type}|套接字类型
s.proto|套接字协议

### 创建 TCP 服务器

首先，我们将展现创建通用 TCP 服务器的一般伪代码，然后对这些代码的含义进行一般 性的描述。需要记住的是，这仅仅是设计服务器的一种方式。一旦熟悉了服务器设计，那么 你将能够按照自己的要求修改下面的伪代码来操作服务器。

```
ss = socket()# 创建服务器套接字  
ss.bind()# 套接字与地址绑定 
ss.listen() # 监听连接
inf_loop: # 服务器无限循环
   cs = ss.accept() # 接受客户端连接
   comm_loop:# 通信循环
       cs.recv()/cs.send() # 对话(接收/发送)
   cs.close() # 关闭客户端套接字
ss.close() # 关闭服务器套接字#(可选)
```

所有套接字都是通过使用 socket.socket()函数来创建的。因为服务器需要占用一个端口并 等待客户端的请求，所以它们必须绑定到一个本地地址。因为 TCP 是一种面向连接的通信系 统，所以在 TCP 服务器开始操作之前，必须安装一些基础设施。特别地，TCP 服务器必须监 听(传入)的连接。一旦这个安装过程完成后，服务器就可以开始它的无限循环。

调用 accept()函数之后，就开启了一个简单的(单线程)服务器，它会等待客户端的连接。 默认情况下，accept()是阻塞的，这意味着执行将被暂停，直到一个连接到达。另外，套接字 确实也支持非阻塞模式，可以参考文档或操作系统教材，以了解有关为什么以及如何使用非 阻塞套接字的更多细节

一旦服务器接受了一个连接，就会返回(利用 accept())一个独立的客户端套接字，用来 与即将到来的消息进行交换。使用新的客户端套接字类似于将客户的电话切换给客服代表。 当一个客户电话最后接进来时，主要的总机接线员会接到这个电话，并使用另一条线路将这 个电话转接给合适的人来处理客户的需求。

这将能够空出主线(原始服务器套接字)，以便接线员可以继续等待新的电话(客户请求)， 而此时客户及其连接的客服代表能够进行他们自己的谈话。同样地，当一个传入的请求到达 时，服务器会创建一个新的通信端口来直接与客户端进行通信，再次空出主要的端口，以使 其能够接受新的客户端连接。

一旦创建了临时套接字，通信就可以开始，通过使用这个新的套接字，客户端与服务器 就可以开始参与发送和接收的对话中，直到连接终止。当一方关闭连接或者向对方发送一个 空字符串时，通常就会关闭连接。

在代码中，一个客户端连接关闭之后，服务器就会等待另一个客户端连接。最后一行代 码是可选的，在这里关闭了服务器套接字。其实，这种情况永远也不会碰到，因为服务器应 该在一个无限循环中运行。在示例中这行代码用来提醒读者，当为服务器实现一个智能的退 出方案时，建议调用 close()方法。例如，当一个处理程序检测到一些外部条件时，服务器就应该关闭。在这些情况下，应该调用一个 close()方法。

```
***核心提示:多线程处理客户端请求***

我们没在该例子中实现这一点，但将一个客户端请求切换到一个新线程或进程来完成 客户端处理也是相当普遍的。SocketServer 模块是一个以 socket 为基础而创建的高级套接 字通信模块，它支持客户端请求的线程和多进程处理。可以参考文档或在第 4 章的练习部 分获取 SocketServer 模块的更多信息。
```

示例 2-1 给出了 tsTserv.py 文件，它是一个 TCP 服务器程序，它接受客户端发送的数据 字符串，并将其打上时间戳(格式:[时间戳]数据)并返回给客户端(“tsTserv”代表时间戳 TCP 服务器，其他文件以类似的方式命名)。


HOST = ''
PORT = 21567
BUFSIZ = 1024
ADDR = (HOST, PORT)

tcpSocket = socket(AF_INET, SOCK_STREAM)
tcpSocket.bind(ADDR)
tcpSocket.listen(5)

ON = True

while ON:
    print('waiting for connection...')
    tcpClientSocket, addr = tcpSocket.accept()
    print('... connect from:', addr)
    
    while True:
        data = tcpClientSocket.recv(BUFSIZ)
        if not data:
            break
        tcpClientSocket.send('[%s] %s' % (ctime(), data))

    tcpClientSocket.close()
tcpSocket.close()

### 创建TCP客户端

```
***核心提示:优雅地退出和调用服务器 close()方法***

在开发中，创建这种“友好的”退出方式的一种方法就是，将服务器的 while 循环放 在一个 try-except 语句中的 except 子句中，并监控 EOFError 或 KeyboardInterrupt 异常，这 样你就可以在 except 或 finally 字句中关闭服务器的套接字。在生产环境中，你将想要能够 以一种更加自动化的方式启动和关闭服务器。在这些情况下，需要通过使用一个线程或创 建一个特殊文件或数据库条目来设置一个标记以关闭服务。
```

### 创建UDP服务器

UDP服务器不需要TCP服务器那么多设置，因为它们不是面向连接的。除了等待传入的连接之外，几乎不需要做其他工作。

伪代码：

```
ss = socket()  # 创建服务器套接字

ss.bind()      # 绑定服务器套接字

inf_loop:      # 服务器无线循环

   cs = ss.recvfrom() / ss.sendto() # 接受、发送

ss.close()    # 关闭服务器套接字

```

从以上伪代码中可以看到，除了普通的创建套接字并将其绑定到本地地址(主机名/端口号 对)外，并没有额外的工作。无限循环包含接收客户端消息、打上时间戳并返回消息，然后回 到等待另一条消息的状态。再一次，close()调用是可选的，并且由于无限循环的缘故，它并不 会被调用，但它提醒我们，它应该是我们已经提及的优雅或智能退出方案的一部分。

UDP 和 TCP 服务器之间的另一个显著差异是，因为数据报套接字是无连接的，所以就 没有为了成功通信而使一个客户端连接到一个独立的套接字“转换”的操作。这些服务器仅 仅接受消息并有可能回复数据。

你将会在示例 2-6 的 tsUserv.p y 中找到代码，这是前面给出的 TCP 服务器的 UDP 版本， 它接受一条客户端消息，并将该消息加上时间戳然后返回客户端。

### 创建 UDP 客户端

在本节中所强调的 4 个客户端中， UDP 客户端的代码是最短的。它的伪代码如下所示。

cs = socket()       # 创建客户端套接字

comm_loop:          # 通信循环
    cs.sendto() / cs.recvfrom() # 对话（发送、接收)
cs.close()          # 关闭客户端套接字

一旦创建了套接字对象，就进入了对话循环之中，在这里我们与服务器交换消息。最后， 当通信结束时，就会关闭套接字。

### socket 模块属性

除了现在熟悉的 socket.socket()函数之外，socket 模块还提供了更多用于网络应用开发的
属性。其中，表 2-2 列出了一些最受欢迎的属性。

---|---
属性|描述
数据属性|
AF_UNIX/AF_INET/AF_INET6/AF_NETLINK/AF_TIPC|Python中支持的套接字地址家族
SO_STREAM、SO_DGRAM|套接字类型(TCP=流，UDP=数据报)
has_ipv6|指示是否支持 IPv6 的布尔标记
异常|
error|套接字相关错误
herror|主机和地址相关错误
gaierror|地址相关
timeout|超时时间
函数|
socket()|以给定的地址家族、套接字类型和协议类型创建一个套接字对象
socketpair()|以给定的地址家族、套接字类型和协议类型(可选)创建一对套接字对象
create_connection()|常规函数，它接收一个地址(主机名，端口号)对，返回套接字对象
fromfd()|以一个打开的文件描述符创建一个套接字对象
ssl()|通过套接字启动一个安全套接字层连接;不执行证书验证
getaddrinfo()|获取一个五元组序列形式的地址信息
getnameinfo()|给定一个套接字地址，返回(主机名，端口号)二元组
getfqdn()|返回完整的域名
gethostname()|返回当前主机名
gethostbyname()|将一个主机名映射到它的 IP 地址
gethostbyname_ex()|gethostbyname()的扩展版本，它返回主机名、别名主机集合和 IP 地址列表
gethostbyaddr()|将一个 IP 地址映射到 DNS 信息;返回与 gethostbyname_ex()相同的 3 元组
getprotobyname()|将一个协议名(如‘tcp’)映射到一个数字
getservbyname()/getservbyport()|将一个服务名映射到一个端口号，或者反过来;对于任何一个函数来说，协议名都是可 选的
ntohl()/ntohs()|将来自网络的整数转换为主机字节顺序
htonl()/htons()|将来自主机的整数转换为网络字节顺序
inet_aton()/inet_ntoa()|将 IP 地址八进制字符串转换成 32 位的包格式，或者反过来(仅用于 IPv4 地址)
inet_pton()/inet_ntop()|将 IP 地址字符串转换成打包的二进制格式，或者反过来(同时适用于 IPv4 和 IPv6 地址)
getdefaulttimeout()/setdefaulttimeout()|以秒(浮点数)为单位返回默认套接字超时时间;以秒(浮点数)为单位设置默认套接 字超时时间

***

## SocketServer 模块

SocketServer是标准库中的一个高级模块(Python 3.x中重命名为socketserver)，它的目 标是简化很多样板代码，它们是创建网络客户端和服务器所必需的代码。这个模块中有为你 创建的各种各样的类，如表 2-3 所示。

通过复制前面展示的基本 TCP 示例，我们将创建一个 TCP 客户端和服务器。你会发现 它们之间存在明显的相似性，但是也应该看到我们如何处理一些繁琐的工作，于是你不必担 心样板代码。这些代表了你能够编写的最简单的同步服务器(为了将你的服务器配置为异步 运行，可以查看本章末尾的练习)。

除了为你隐藏了实现细节之外，另一个不同之处是，我们现在使用类来编写应用程序。 因为以面向对象的方式处理事务有助于组织数据，以及逻辑性地将功能放在正确的地方。 你还会注意到，应用程序现在是事件驱动的，这意味着只有在系统中的事件发生时，它们 才会工作。

SocketServer 模块类

---|---
类|描述
BaseServer|包含核心服务器功能和 mix-in 类的钩子;仅用于推导，这样不会创建这个类
的实例;可以用 TCPServer 或 UDPServer 创建类的实例

TCPServer/UDPServer|基础的网络同步 TCP/UDP 服务器
UnixStreamServer/UnixDatagramServer|基于文件的基础同步 TCP/UDP 服务器
ForkingMixIn/ThreadingMixIn|核心派出或线程功能;只用作 mix-in 类与一个服务器类配合实现一些异步 性;不能直接实例化这个类
ForkingTCPServer/ForkingUDPServer|ForkingMixIn 和 TCPServer/UDPServer 的组合
ThreadingTCPServer/ThreadingUDPServer|ThreadingMixIn 和 TCPServer/UDPServer 的组合
BaseRequestHandler|包含处理服务请求的核心功能;仅仅用于推导，这样无法创建这个类的实例; 可以使用 StreamRequestHandler 或 DatagramRequestHandler 创建类的实例
StreamRequestHandler/DatagramRequestHandler|实现 TCP/UDP 服务器的服务处理器

事件包括消息的发送和接收。事实上，你会看到类定义只包括一个用来接收客户端消息 的事件处理程序。所有其他的功能都来自使用的 SocketServer 类。此外，GUI 编程(见第 5 章)也是事件驱动的。你会立即注意到它们的相似性，因为最后一行代码通常是一个服务器 的无限循环，它等待并响应客户端的服务请求。它工作起来几乎与本章前面的基础 TCP 服务 器中的无限 while 循环一样。

在原始服务器循环中，我们阻塞等待请求，当接收到请求时就对其提供服务，然后继续 等待。在此处的服务器循环中，并非在服务器中创建代码，而是定义一个处理程序，这样当 服务器接收到一个传入的请求时，服务器就可以调用你的函数。

***

## Twisted 框架介绍

Twisted 是一个完整的事件驱动的网络框架，利用它既能使用也能开发完整的异步网络应 用程序和协议。在编写本书时，因为它还不是 Python 标准库的一部分，所以必须单独下载并 安装它(可以使用本章末尾的链接)。它提供了大量的支持来建立完整的系统，包括网络协议、 线程、安全性和身份验证、聊天/ IM、DBM 及 RDBMS 数据库集成、Web/因特网、电子邮件、 命令行参数、GUI 集成工具包等。

使用 Twisted 来实现简单的例子，有点小题大做，但是你必须开始使用它，并且该应用 程序就相当于网络应用程序的“hello world”。

与 SocketServer 类似，Twisted 的大部分功能都存在于它的类中。特别是对于该示例，我 们将使用 Twisted 因特网组件中的 reactor 和 protocol 子包中的类。


