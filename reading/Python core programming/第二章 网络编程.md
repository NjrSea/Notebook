# 第二章 网络编程

***

## 客户端/服务器架构

### 硬件客户端/服务器架构

打印(打印机)服务器是硬件服务器的一个例子。它们处理传入的打印作业并将其发送 给系统中的打印机(或其他的打印设备)。这样的计算机通常可以通过网络进行访问，并且客
户端计算机将向它发送打印请求。

硬件服务器的另一个例子就是文件服务器。这些通常都是拥有庞大通用存储容量的计算
机，可以被客户端远程访问。客户端计算机会挂载服务器计算机上的磁盘，看起来好像这个 磁盘就在本地计算机上一样。支持文件服务器的一个最流行的网络操作系统就是 Sun 公司的 网络文件系统(NFS)。如果你正在访问一个网络磁盘驱动器，并且无法分辨它是在本地还是 网络上，那么此时客户端/服务器系统就已经完成了它的任务。它的目标就是让用户得到与访 问本地磁盘完全相同的体验，抽象起来就是正常的磁盘访问，而这些都是通过编程实现来确 保以这种方式进行。

### 软件客户端/服务器架构

现在一个更常见的软件服务器就是 Web 服务器。如果个人或公司想要运行自己的 Web 服务 器，那么必须拥有一台或多台计算机，在上面安装希望提供给用户的 Web 页面和 Web 应用程序， 然后启动 Web 服务器。一个这样的服务器的工作就是接受客户端请求，并向(Web)客户端(即 用户计算机上的浏览器)回送 Web 页面，然后等待下一个客户端的请求。这些服务器一旦开启， 都将可能永远运行。虽然它们并不能实现这一目标，但是它们会尽可能长时间地运行，除非受到 一些外力驱使才会停止，如显式地关闭，或灾难性地关闭(由于硬件故障)。
数据库服务器是另一种类型的软件服务器。它们接受客户端的存储或检索请求，响应请 求，然后等待更多的事务。与 Web 服务器类似，它们也是永远运行的。

***

### 套接字

套接字是计算机网络数据结构，它体现了上节中所描述的“通信端点”的概念。在任何 类型的通信开始之前，网络应用程序必须创建套接字。可以将它们比作电话插孔，没有它将 无法进行通信。

套接字的起源可以追溯到 20 世纪 70 年代，它是加利福尼亚大学的伯克利版本 UNIX(称 为 BSD UNIX)的一部分。因此，有时你可能会听过将套接字称为伯克利套接字或 BSD 套接 字。套接字最初是为同一主机上的应用程序所创建，使得主机上运行的一个程序(又名一个 进程)与另一个运行的程序进行通信。这就是所谓的进程间通信(Inter Process Communication， IPC)。有两种类型的套接字:基于文件的和面向网络的。

UNIX 套接字是我们所讲的套接字的第一个家族，并且拥有一个“家族名字”AF_UNIX (又名AF_LOCAL，在POSIX1.g标准中指定)，它代表地址家族(address family):UNIX。 包括 Python 在内的大多数受欢迎的平台都使用术语地址家族及其缩写 AF;其他比较旧的系 统可能会将地址家族表示成域(domain)或协议家族(protocol family)，并使用其缩写 PF 而 非 AF。类似地，AF_LOCAL(在 2000~2001 年标准化)将代替 AF_UNIX。然而，考虑到 后向兼容性，很多系统都同时使用二者，只是对同一个常数使用不同的别名。Python 本身仍
然在使用 AF_UNIX。

因为两个进程运行在同一台计算机上，所以这些套接字都是基于文件的，这意味着文件 系统支持它们的底层基础结构。这是能够说得通的，因为文件系统是一个运行在同一主机上 的多个进程之间的共享常量。

第二种类型的套接字是基于网络的，它也有自己的家族名字 AF_INET，或者地址家族: 因特网。另一个地址家族 AF_INET6 用于第 6 版因特网协议(IPv6)寻址。此外，还有其他 的地址家族，这些要么是专业的、过时的、很少使用的，要么是仍未实现的。在所有的地址 家族之中，目前 AF_INET 是使用得最广泛的

Python 2.5 中引入了对特殊类型的 Linux 套接字的支持。套接字的 AF_NETLINK 家族(无 连接[见 2.3.3 节])允许使用标准的 BSD 套接字接口进行用户级别和内核级别代码之间的 IPC。 之前那种解决方案比较麻烦，而这个解决方案可以看作一种比前一种更加优雅且风险更低的 解决方案，例如，添加新系统调用、/proc 支持，或者对一个操作系统的“IOCTL”。
针对Linux的另一种特性(Python 2.6中新增)就是支持透明的进程间通信(TIPC)协 议。TIPC 允许计算机集群之中的机器相互通信，而无须使用基于 IP 的寻址方式。Python 对 TIPC 的支持以 AF_TIPC 家族的方式呈现。
总的来说，Python 只支持 AF_UNIX、AF_NETLINK、AF_TIPC 和 AF_INET 家族。因为 本章重点讨论网络编程，所以在本章剩余的大部分内容中，我们将使用 AF_INET。

### 套接字地址:主机-端口对

如果一个套接字像一个电话插孔——允许通信的一些基础设施，那么主机名和端口号就 像区号和电话号码的组合。然而，拥有硬件和通信的能力本身并没有任何好处，除非你知道 电话打给谁以及如何拨打电话。一个网络地址由主机名和端口号对组成，而这是网络通信所 需要的。此外，并未事先说明必须有其他人在另一端接听;否则，你将听到这个熟悉的声音
“对不起，您所拨打的电话是空号，请核对后再拨”。你可能已经在浏览网页的过程中见过一 个网络类比，例如“无法连接服务器，服务器没有响应或者服务器不可达。”
有效的端口号范围为 0~65535(尽管小于 1024 的端口号预留给了系统)。如果你正在使 用 POSIX 兼容系统(如 Linux、Mac OS X 等)，那么可以在/etc/services 文件中找到预留端口 号的列表(以及服务器/协议和套接字类型)。众所周知的端口号列表可以在这个网站中查看: http://www.iana.org/assignments/port-numbers。

### 面向连接的套接字与无连接的套接字

*** 1.面向连接的套接字***

不管你采用的是哪种地址家族，都有两种不同风格的套接字连接。第一种是面向连接的， 这意味着在进行通信之前必须先建立一个连接，例如，使用电话系统给一个朋友打电话。这 种类型的通信也称为虚拟电路或流套接字。

面向连接的通信提供序列化的、可靠的和不重复的数据交付，而没有记录边界。这基本 上意味着每条消息可以拆分成多个片段，并且每一条消息片段都确保能够到达目的地，然后 将它们按顺序组合在一起，最后将完整消息传递给正在等待的应用程序

实现这种连接类型的主要协议是传输控制协议(更为人熟知的是它的缩写 TCP)。为 了 创建 TCP 套接字，必须使用 SOCK_STREAM 作为套接字类型。TCP 套接字的名字 SOCK_STREAM 基于流套接字的其中一种表示。因为这些套接字(AF_INET)的网络版本 使用因特网协议(IP)来搜寻网络中的主机，所以整个系统通常结合这两种协议(TCP 和 IP) 来进行(当然，也可以使用 TCP 和本地[非网络的 AF_LOCAL/AF_UNIX]套接字，但是很明 显此时并没有使用 IP)。

*** 2.无连接的套接字***

与虚拟电路形成鲜明对比的是数据报类型的套接字，它是一种无连接的套接字。这意味 着，在通信开始之前并不需要建立连接。此时，在数据传输过程中并无法保证它的顺序性、 可靠性或重复性。然而，数据报确实保存了记录边界，这就意味着消息是以整体发送的，而 并非首先分成多个片段，例如，使用面向连接的协议。

使用数据报的消息传输可以比作邮政服务。信件和包裹或许并不能以发送顺序到达。 事实上，它们可能不会到达。为了将其添加到并发通信中，在网络中甚至有可能存在重复 的消息。

既然有这么多副作用，为什么还使用数据报呢(使用流套接字肯定有一些优势)?由于面 向连接的套接字所提供的保证，因此它们的设置以及对虚拟电路连接的维护需要大量的开销。 然而，数据报不需要这些开销，即它的成本更加“低廉”。因此，它们通常能提供更好的性能， 并且可能适合一些类型的应用程序。

实现这种连接类型的主要协议是用户数据报协议(更为人熟知的是其缩写 UDP)。为 了 创建 UDP 套接字，必须使用 SOCK_DGRAM 作为套接字类型。你可能知道，UDP 套接字的 SOCK_DGRAM 名字来自于单词“datagram”(数据报)。因为这些套接字也使用因特网协议 来寻找网络中的主机，所以这个系统也有一个更加普通的名字，即这两种协议(UDP 和 IP) 的组合名字，或 UDP/IP。

***

## Python 中的网络编程

### socket() 模块函数

要创建套接字，必须使用 socket.socket()函数，它一般的语法如下。

```
socket(socket_family, socket_type, protocol=0)
```

其中，socket_family 是 AF_UNIX 或 AF_INET(如前所述)，socket_type 是 SOCK_STREAM 或 SOCK_DGRAM(也如前所述)。protocol 通常省略，默认为 0。

所以，为了创建 TCP/IP 套接字，可以用下面的方式调用 socket.socket()。

```
tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

同样，为了创建 UDP/IP 套接字，需要执行以下语句。

udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

因为有很多 socket 模块属性，所以此时使用“from module import *”这种导入方式可以 接受，不过这只是其中的一个例外。如果使用“from socket import *”，那么我们就把 socket 属性引入到了命名空间中。虽然这看起来有些麻烦，但是通过这种方式将能够大大缩短代码， 正如下面所示。

tcpSock = socket(AF_INET, SOCK_STREAM)

一旦有了一个套接字对象，那么使用套接字对象的方法将可以进行进一步的交互。

### 套接字对象(内置)方法

表 2-1 列出了最常见的套接字方法。在下一节中，我们将使用其中的一些方法创建 TCP 和 UDP 客户端与服务器。虽然我们专注于网络套接字，但这些方法与使用本地/不联网的套 接字时有类似的含义。

表 2-1 常见的套接字对象方法和属性

---|---
名称|描述
s.bind()|将地址(主机名、端口号对)绑定到套接字上
s.listen()|设置并启动 TCP 监听器
s.accept()|被动接受 TCP 客户端连接，一直等待直到连接到达(阻塞)

s.connect()|主动发起 TCP 服务器连接
s.connect_ex()|connect()的扩展版本，此时会以错误码的形式返回问题，而不是抛出一个异常

s.recv()|接收 TCP 消息
s.recv_into()|接收 TCP 消息到指定的缓冲区
s.send()|发送 TCP 消息
s.sendall()|完整地发送 TCP 消息
s.recvfrom()|接收 UDP 消息
s.recvfrom_into()|接收 UDP 消息到指定的缓冲区
s.sendto()|发送 UDP 消息
s.getpeername()|连接到套接字(TCP)的远程地址
s.getsockname()|当前套接字的地址
s.getsockopt()|返回给定套接字选项的值
s.setsockopt()|设置给定套接字选项的值
s.shutdown()|关闭连接
s.close()|关闭套接字
s.detach()|在未关闭文件描述符的情况下关闭套接字，返回文件描述符
s.ioctl()|控制套接字的模式(仅支持 Windows)

s.setblocking()|设置套接字的阻塞或非阻塞模式
s.settimeout()|设置阻塞套接字操作的超时时间
s.gettimeout()|获取阻塞套接字操作的超时时间

s.fileno()|套接字的文件描述符
s.makefile()|创建与套接字关联的文件对象

s.family|套接字家族
s.type}|套接字类型
s.proto|套接字协议



