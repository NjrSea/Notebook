# 第三章 网络客户端编程

第 2 章介绍了使用套接字的底层网络通信协议。这种类型的网络是当今因特网中大部分 客户端/服务器协议的核心。这些网络协议分别用于文件传输(FTP、SCP 等)、阅读 Usenet 新闻组(NNTP)、发送电子邮件(SMTP)、从服务器上下载电子邮件(POP3、IMAP)等。 协议的工作方式与第 2 章介绍的客户端/服务器的例子相似。唯一区别在于现在使用 TCP/IP 这样底层的协议创建了新的、有专门用途的协议，以此来实现刚刚介绍的高层服务。

***

## 文件传输

因特网中最常见的事情就是传输文件。文件传输每时每刻都在发生。有很多协议可以用 于在因特网上传输文件。最流行的包括文件传输协议(FTP)、UNIX 到 UNIX 复制协议 (UUCP)、用于 Web 的超文本传输协议(HTTP)。另外，还有(UNIX 下的)远程文件复制
命令 rcp(以及更安全、更灵活的 scp 和 rsync)。
在当下，HTTP、FTP、scp/rsync 的应用仍然非常广泛。HTTP 主要用于基于 Web 的文件
下载以及访问 Web 服务，一般客户端无须登录就可以访问服务器上的文件和服务。大部分 HTTP 文件传输请求都用于获取网页(即将网页文件下载到本地)。

而 scp 和 rsync 需要用户登录到服务器主机。在传输文件之前必须验证客户端的身份，否则 不能上传或下载文件。FTP 与 scp/rsync 相同，它也可以上传或下载文件，并采用了 UNIX 的多 用户概念，用户需要输入有效的用户名和密码。但 FTP 也允许匿名登录。现在来深入了解 FTP。

### 文件传输协议

文件传输协议(File Transfer Protocol，FTP)由已故的 Jon Postel 和 Joyce Reynolds 开发， 记录在RFC(Request for Comment)959号文档中，于1985年10月发布。FTP主要用于匿 名下载公共文件，也可以用于在两台计算机之间传输文件，特别是在使用 Windows 进行工作， 而文件存储系统使用 UNIX 的情况下。早在 Web 流行之前，FTP 就是在因特网上进行文件传 输以及下载软件和源代码的主要手段之一。

前面提到过，FTP 要求输入用户名和密码才能访问远程 FTP 服务器，但也允许没有账号的 用户匿名登录。过管理员要先设置 FTP 服务器以允许匿名用户登录。这时，匿名用户的用户 名是“anonymous”，密码一般是用户的电子邮件地址。与向特定的登录用户传输文件不同，这 相当于公开某些目录让大家访问。但与登录用户相比，匿名用户只能使用有限的几个 FTP 命令。

图 3-1 展示了这个协议，其工作流程如下。

1)客户端连接远程主机上的 FTP 服务器。

2)客户端输入用户名和密码

3)客户端进行各种文件传输和信息查询操作

4) 客户端从远程 FTP 服务器退出，结束传输

当然，这只是一般情况下的流程。有时，由于网络两边计算机的崩溃或网络的问题，会 导致整个传输在完成之前就中断。如果客户端超过 15 分钟(900 秒)还没有响应，FTP 连接 就会超时并中断。

在底层，FTP 只使用 TCP(见第 2 章)，而不使用 UDP。另外，可以将 FTP 看作客户 端/服务器编程中的特殊情况。因为这里的客户端和服务器都使用两个套接字来通信:一个 是控制和命令端口(21 号端口)，另一个是数据端口(有时是 20 号端口)，如图 3-1 所示。

前面说“有时”是因为 FTP 有两种模式:主动和被动。只有在主动模式下服务器才使用 数据端口。***在服务器把 20 号端口设置为数据端口后，它“主动”连接客户端的数据端口。而 在被动模式下，服务器只是告诉客户端随机的数据端口号，客户端必须主动建立数据连接。***

在这种模式下，FTP 服务器在建立数据连接时是“被动”的。最后，现在已经有了一种扩展 的被动模式来支持第 6 版本的因特网协议(IPv6)地址——详见 RFC 2428。

Python 已经支持了包括 FTP 在内的大多数据因特网协议。可以在 http://docs.python. org/lib/internet.html 中找到支持各个协议的客户端模块。现在看看用 Python 创建因特网客户 端程序有多么容易。

### Python 和 FTP

那么如何用 Python 编写 FTP 客户端程序呢?其实之前已经提到过一些了，现在还要添 加相应的 Python 模块导入和调用操作。再回顾一下流程。

1) 连接到服务器

2) 登录

3) 发送服务请求（希望能得到相应）

4) 退出

在使用Python的ftp支持时，所有要做的只是导入ftplib模块，并实例化一个ftplib.FTP类对象。所有的 FTP 操作(如登录、传输文件和注销等)都要使用这个对象完成。

下面是一段 Python 伪代码。

```
from ftplib import FTP

f = FTP('some.ftp.server')

f.login('anonymous', 'your@email.address')
...
f.quit()
```

### ftplib.FTP 类的方法

----|----
方法|描述
login(user='anonymous', passwd='', acct='')|登录 FTP 服务器，所有参数都是可选的

pwd()|获得当前工作目录

cwd(path)|把当前工作目录设置为 path 所示的路径

dir ([path[,...[,cb]])|显示 path 目录里的内容，可选的参数 cb 是一个回调函数，会传递给 retrlines()方法

nlst ([path[,...])|与 dir()类似，但返回一个文件名列表，而不是显示这些文件名

retrlines(cmd [, cb])|给定 FTP 命令(如“RETR filename”)，用于下载文本文件。可选的回调函数 cb 用于处理文件的每一行

retrbinary(cmd,
cb[,bs=8192[, ra]])| 与 retrlines()类似，只是这个指令处理二进制文件。回调函数 cb 用于处理每一块(块大小默认为 8KB) 下载的数据

storlines(cmd, f)|给定 FTP 命令(如“STOR filename”)，用来上传文本文件。要给定一个文件对象 f

storbinary(cmd, f [,bs=8192])|与 storlines()类似，只是这个指令处理二进制文件。要给定一个文件对象 f，上传块大小 bs 默认为 8KB

rename(old, new)|把远程文件 old 重命名为 new

delete(path)|删除位于path的文件

mkd(directory)|创建远程目录
rmd(directory)|删除远程目录 
quit()|关闭连接并退出

在一般的 FTP 事务中，要使用到的指令有 login()、cwd()、dir()、pwd()、stor*()、retr*() 和 quit()。表 3-1 中没有列出的一些 FTP 对象方法也很有用。关于 FTP 对象的更多信息，请 参阅 http://docs.python.org/library/ftplib#ftp-objects 中的 Python 文档。

在 Python 中使用 FTP 非常简单，甚至都不用写脚本，直接在交互式解释器中就能实时 地看到操作步骤和输出。下面这个示例会话是在几年前 python.org 还支持 FTP 服务器的时候 做的。现在这个示例已经无法工作，只是用来演示与正在运行的 FTP 服务器进行交互的情形。

```
>>> from ftplib import FTP
>>> f = FTP('ftp.python.org')
>>> f.login('anonymous', 'guido@python.org') '230 Guest login ok, access restrictions apply.' >>> f.dir()
total 38
drwxrwxr-x 10 1075
drwxrwxr-x 10 1075
drwxr-xr-x 3 root
drwxr-sr-x 3 root
drwxr-xr-x 3 root
lrwxrwxrwx 1 root
-r--r--r-- 1 guido
drwxrwsr-x 8 1122
drwxr-xr-x 5 root
>>> f.retrlines('RETR motd')
Sun Microsystems Inc. SunOS 5.6
'226 Transfer complete.
>>> f.quit()
'221 Goodbye.'
```

### 客户端 FTP 程序示例

前面提到过，如果直接在交互环境中使用 FTP 就无须编写脚本。但下面还是编写一段脚 本，用来从 Mozilla 的网站下载最新的 Bugzilla 代码。示例 3-1 就用来完成这个工作。虽然这 里在尝试编写一个应用程序，但读者也可以交互式地运行这段代码。这个程序使用 FTP 库下 载文件，其中也包含一些错误检查。

```
#!/usr/bin/env python

import ftplib
import os
import socket

HOST = 'ftp.mozilla.org'
DIRN = 'pub/mozilla.org/webtools'
FILE = 'bugzilla-LATEST.tar.gz'

def main():
    try:
       f = ftplib.FTP(HOST)
    excpt (socket.error, socket.gaierror) as e:
       print('ERROR: cannot reach "%s"' % HOST
       return
    
    ....
```

不过脚本并不会自动运行，需要手动运行才会下载代码。如果使用的是类 UNIX 系统， 可以设定一个 cron 作业来自动下载。另一个问题是，如果需要下载的文件的文件名或目录名 被修改了，程序就无法正常工作。

以下是一些典型的 FTP 客户端类型。

* 命令行客户端程序:使用一些 FTP 客户端程序(如/bin/ftp 或 NcFTP)进行 FTP 传
输，用户可以在命令行中交互式执行 FTP 传输。

* GUI 客户端程序:与命令行客户端程序相似，但它是一个 GUI 程序，如 WS_FTP、
Filezilla、CuteFTP、Fetch、SmartFTP。

* Web 浏览器:除了使用 HTTP 之外，大多数 Web 浏览器(也称为客户端)可以进行 FTP
传输。URL/URI 的第一部分就用来表示所使用的协议，如“http://blahblah”。这就告诉浏 览器要使用 HTTP 作为与指定网站传输数据的协议。通过修改协议部分，就可以发送使 用 FTP 的请求，如“ftp://blahblah”，这与使用 HTTP 的网页 URL 很像(当然，“ftp://” 后面的“blahblah”可以展开为“host/path?attributes”)。如果要登录，用户可以把登录信 息(以明文方式)放在URL里，如:“ftp://user:passwd@host /path?attr1=val1&attr2=val2. . .”。

* 自定义应用程序:自己编写的用于 FTP 文件传输的程序。这些是用于特殊目的的应 用程序，一般这种程序不允许用户与服务器交互。


***

## 网络新闻

Usenet 新闻系统是一个全球存档的“电子公告板”。各种主题的新闻组一应俱全，从诗 歌到政治，从自然语言学到计算机语言，从软件到硬件，从种植到烹饪、招聘/应聘、音乐、 魔术、相亲等。新闻组可以面向全球，也可以只面向某个特定区域。


整个系统是一个由大量计算机组成的庞大的全球网络，计算机之间共享 Usenet 上的帖 子。如果某个用户发了一个帖子到本地的 Usenet 计算机上，这个帖子会被传播到其他相连 的计算机上，再由这些计算机传到与它们相连的计算机上，直到这个帖子传播到了全世界， 每个人都收到这个帖子为止。帖子在 Usenet 上的存活时间是有限的，这个时间可以由 Usenet 系统管理员来指定，也可以为帖子指定一个过期的日期/时间。

每个系统都有一个已“订阅”的新闻组列表，系统只接收感兴趣的新闻组里的帖子，而不是 接收服务器上所有新闻组的帖子。Usenet 新闻组的内容由提供者安排，很多服务都是公开的。但 也有一些服务只允许特定用户使用，例如付费用户、特定大学的学生等。Usenet 系统管理员可能 会进行一些设置来要求用户输入用户名和密码，管理员也可以设置是否只能上传或只能下载。

Usenet 正在逐渐退出人们的视线，主要被在线论坛替代。但依然值得在这里提及，特别 是它的网络协议。老的 Usenet 使用 UUCP 作为其网络传输机制，在 20 世纪 80 年代中期出现了另一个网络 协议 TCP/IP，之后大部分网络流量转向使用 TCP/IP。下一节将介绍这个新的协议。

### 网络新闻传输协议

用户使用网络新闻传输协议(NNTP)在新闻组中下载或发表帖子。该协议由 Brain Kantor (加州大学圣地亚哥分校)和 Phil Lapsley(加州大学伯克利分校)创建并记录在 RFC 977 中，
于 1986 年 2 月公布。其后在 2000 年 10 月公布的 RFC 2980 中对该协议进行了更新。 作为客户端/服务器架构的另一个例子，NNTP 与 FTP 的操作方式相似，但更简单。在 FTP 中，登录、传输数据和控制需要使用不同的端口，而 NNTP 只使用一个标准端口 119 来
通信。用户向服务器发送一个请求，服务器就做出相应的响应，如图 3-2 所示。


### Python 和 NNTP

由于之前已经有了 Python 和 FTP 的经验，读者也许可以猜到，有一个 nntplib 库和一个 需要实例化的 nntplib.NNTP 类。与 FTP 一样，所要做的就是导入这个 Python 模块，然后调 用相应的方法。先大致看一下这个协议。

1)连接到服务器。

2)登录(根据需要)。

3)发出服务请求。

4)退出。

是不是有点熟悉?是的，这与 FTP 协议极其相似。唯一的区别是根据 NNTP 服务器配置的不同，登录这一步是可选的。

***

## 电子邮件

电子邮件既古老又现代。对于作者这些很早之前就开始使用因特网的人来说，电子邮件 看上去都非常“古老”，更不用说与今日基于网页的在线聊天、即时聊天(IM)、数字电话(如 VoIP[Voice over Internet Protocol])等更新、更快的通信方式相比了。下面将从宏观上介绍 一下电子邮件是如何工作的。如果读者已经了解相关内容，只想学习用 Python 做电子邮件相 关的开发，可以跳到下一节。

在介绍电子邮件的基础架构之前，读者是否真正了解电子邮件的确切定义呢?根据 RFC 2822 的定义，“(电子邮件)消息由头字段(统称消息标题)以及后面可选的正文组成”。 对于一般用户来说，一说起电子邮件，无论是一封真的邮件，还是一封不请自来的商业广 告(即垃圾邮件)，都会想到邮件正文。不过 RFC 规定，邮件可以没有正文，但一定要有 邮件标题，这一点要特别注意。

### 电子邮件系统组件和协议

不管读者是怎么认为的，实际上电子邮件诞生在现代因特网出现之前。电子邮件一开始 用于在不同主机用户之间简单交换消息。注意，因为这些用户都使用同一台计算机，所以这 里还没有涉及网络。在网络出现之后，用户就可以在不同的主机之间交换消息。当然，由于 用户使用不同的计算机，计算机之间使用不同的协议，消息交换是一个很复杂的概念。直到 20 世纪 80 年代，因特网上收发电子邮件才有一个事实上的统一标准。

在深入细节之前，不禁想问，电子邮件是怎么工作的?一条消息是如何从发件人那里通 过浩瀚的因特网到达收件人的?简单点来说，有一台发送计算机(发件人的消息从这里发送 出去)和一台接收计算机(收件人的邮件服务器)。最好的解决方案是发送计算机知道如何连 接到接收计算机，这样就可以直接把消息发送过去。但实际上一般没有这么顺利。

发送计算机需要找到某一台中间主机，而这台中间主机最终能到达最后的接收主机。接 着这台中间主机需要找到一台离接收主机更近一些的主机。所以，在发送主机和接收主机之 间，可能会有多台称为跳板的主机。如果仔细看看收到的电子邮件消息头标题，会看到一个
“护照”标记，其中记录了这封邮件最终抵达之前，一路上都到过哪些地方。
