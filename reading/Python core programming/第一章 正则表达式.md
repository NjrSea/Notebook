# 第一章 正则表达式

使用字符串可以匹配相应的字符串，如：正则表达式foo可以匹配foo.

----|----|----
-表示法-|----|-正则表达式示例-
符号
literal|匹配文本字符串的字面值literal|foo
re1|re2|匹配正则表达式re1或者re2|foo|bar
.|匹配任何字符（除了\n)|b.b
^|匹配字符串启示部分|^Dear
*|匹配0次或者多次前面出现的正则表达式|[A-Za-z0-9]*
+|匹配1次或者多次前面出现的正则表达式|[a-z]+\.com
?|匹配0次或者1次出现的正则表达式|goo?
{N}|匹配N次前面出现的正则表达式|[0-9]{3}
{M,N}|匹配M~N次前面出现的正则表达式|[0-9]{5,9}
[...]|匹配来自字符集的任意单一字符|[aeiou]
[..x-y..]|匹配x~y范围中的任意单一字符|[0-9],[A-Za-z]
[^...]|不匹配次字符集中出现的任一个字符|[^aeiou]
(*|+|?|{})?|用于匹配上面频繁出现、重复出现符号的非贪婪版本|.*?[a-z]
(...)|匹配封闭的正则表达式，然后另存为子组|([0-9]{3})?,f(oo|u)bar
特殊字符
\d|匹配任何十进制数字，与[0-9]一致(\D与\d相反，匹配任何非数值型的数字)|data\d+.txt
\w|匹配任何字母数字字符，与[A-Za-z0-9]相同(\W与之相反)|[A-Za-z_]\w+
\s|匹配任何空格字符串，与[\n\t\r\v\f]相同，（\S相反)|of\sthe
\b|匹配任何单词边界(\B与之相反)|\bThe\b
\N|匹配以保存的子组|price:\16 // TODO：不清楚
\c|逐字匹配任何特殊字符c（转义)|\.,\\,\*
\A(\Z)|匹配字符串的启示（结束）（另见^和$)|\ADear
扩展表示法
(?iLmsux)|在正则表达式中嵌入一个或者多个特殊“标记”参数（或者通过函数/方法)|（?x),(? im) // TODO:不清楚
(?:...)|表示一个匹配不用保存的分组|(?:\w+\.)*
(?p<name>...)|像一个由name标识而不是数字ID标识的正则分组匹配|(?P<data>)
(?P=name)|在同一个字符串中匹配由(?P<name)分组的之前文本|(?P=data)
(?#...)|表示注释，所有内容都被忽略|(?#comment)
(?=...)|匹配条件是如果...出现之后的位置，而不使用输入字符串；称作正向前视断言)|(?=.com) // TODO:
(?!...)|匹配条件是如果...不出现在之后的位置，而不使用输入字符串；称作负向前视断言|(?!.net)
(?<=...)|匹配条件是如果..出现在之前的位置，而不使用输入字符串；称作正向后视断言|(?<=800-)
(?<!...)|匹配条件是如果...不出现在之前的位置，而不使用输入字符串;称作负向后视断言|(?<!192\.168\.)
(?(id/name)Y|N )|如果分组提供的id或者name存在，就返回正则表达式的条件匹配Y，如果不存在，就返回N；|N是可选项|(?(1)y|x) // TODO:


### 使用择一匹配符号匹配多个正则表达式模式

键盘上的竖线(|),表示择一匹配符号，既从多个模式中选择其一。

正则表达式模式      匹配的字符串
  
at | home            at、home


### 从字符串起始或者结尾或者单词边界匹配

正则表达式模式      匹配的字符串

^From               任何以 From 作为起始的字符串
/bin/tcsh$          任何以/bin/tcsh 作为结尾的字符串
^Subject: hi$       任何由单独的字符串 Subject: hi 构成的字符串

***\b和\B的区别***

\b将用于匹配一个单词的边界，这意味着如果一个模式必须位于单词的起始部分，就不管该单词前面是否有任何字符。同样，\B将匹配出现在一个单词中间的模式。

正则表达式模式           匹配的字符串

the                      任何包含 the 的字符串

\bthe                    任何以 the 开始的字符串

\bthe\b                  仅仅匹配单词 the

\Bthe                    任何包含但并不以 the 作为起始的字符串

### 创建字符集

正则表达式模式           匹配的字符串

b[aeiu]t                 bat、bet、bit、but

[cr][23][dp][o2]         一个包含四个字符的字符串，第一个字符是“c”或“r”，然后是“2”或“3”，后面 是“d”或“p”，最后要么是“o”要么是“2”。例如，c2do、r3p2、r2d2、c3po 等

### 限定范围和否定

正则表达式模式           匹配的字符串

z.[0-9]                  字母“z”后面跟着任何一个字符，然后跟着一个数字

[r-u][env-y][us]         字母“r”、“s”、“t”或者“u”后面跟着“e”、“n”、“v”、“w”、“x”或者“y”，然后跟着“u”或者“s”

[^\t\n]                  不匹配制表符或者\n

[“-a]                    在一个 ASCII 系统中，所有字符都位于“”和“a”之间，即 34~97 之间

### 贪婪匹配&非贪婪匹配 // TODO: https://blog.csdn.net/u014762221/article/details/68953155        https://blog.csdn.net/chenlycly/article/details/54982537   https://segmentfault.com/q/1010000008733200/a-1020000008801225/revision

贪婪模式或者是非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎(不确定有穷自动机)所支持。

属于贪婪模式的量词，也叫做匹配优先量词，包括：

"{m,n}" "{m,}" "?" "*" "+"

在一些使用NFA引擎的语言中，在匹配优先量词后加上"?",即变成属于非贪婪模式的量词，也叫做忽略优先量词，包括：

"{m,n}?" "{m,}?" "??" "*?" "+?"

从正则语法的角度来讲，被匹配优先量词修饰的子表达式使用的就是贪婪模式，如"(Expression)+";被忽略优先量词修饰的子表达式使用的就是非贪婪模式，如"(Expression)+"。


#### 贪婪模式与非贪婪模式匹配原理

对于贪婪与非贪婪模式，可以从应用和原理两个角度进行理解，但如果想真正掌握，还是要从匹配原理来理解的。

举例：

源字符串：aa<div>test1</div>bb<div>test2</div>cc 

正则表达式一：<div>.*</div> 

匹配结果：<div>test1</div>bb<div>test2</div>

正则表达式二：<div>.*?</div> 

匹配结果二：<div>test1</div>（这里指的是一次匹配结果，所以没包括<div>test2</div>） 

仅从应用角度分析，可以这样认为，贪婪模式，就是在整个表达式匹配成功的前提下，尽可能多的匹配，也就是所谓的“贪婪”，通俗点讲，就是看到想要的，有多少就捡多少，除非再也没有想要的了。 

正则表达式二采用的是非贪婪模式，在匹配到第一个“</div>”时使整个表达式匹配成功，由于采用的是非贪婪模式，所以结束匹配，不再向右尝试，匹配结果为“<div>test1</div>”。 

仅从应用角度分析，可以这样认为，非贪婪模式，就是在整个表达式匹配成功的前提下，尽可能少的匹配，也就是所谓的“非贪婪”，通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了。 

#### 关于前提条件的说明

在上面从应用角度分析贪婪与非贪婪模式时，一直提到的一个前提条件就是“整个表达式匹配成功”，为什么要强调这个前提，我们看下下面的例子。 

正则表达式三：<div>.*</div>bb

匹配结果三：<div>test1</div>bb

修饰"."的仍然是匹配优先量词"*"，所以这里还是贪婪模式，前面的"<div>.*</div>"仍然可以匹配到"<div>test1</div>bb<div>test2</div>",但是由于后面的“bb“无法匹配成功，这时”<div>.*</div>“必须让出已匹配的bb<div>test2</div>,以使整个表达式匹配成功。这时整个表达式匹配的结果是<div>test1</div>bb，“<div>.*</div>”匹配的内容为“<div>test1</div>”。可以看到，在“整个表达式匹配成功”的前提下，贪婪模式才真正的影响着子表达式的匹配行为，如果整个表达式匹配失败，贪婪模式只会影响匹配过程，对匹配结果的影响无从谈起。 

***非贪婪模式也存在同样的问题，来看下面的例子。 ***

正则表达式四：<div>.*?</div>cc 匹配结果四：<div>test1</div>bb<div>test2</div>cc


#### 贪婪还是非贪婪——应用的抉择

对于一些简单的需求，比如源字符为“aa<div>test1</div>bb”，那么取得div标签，使用贪婪与非贪婪模式都可以取得想要的结果，使用哪一种或许关系不大。 

但是就2.1.1中的例子来说，实际应用中，一般一次只需要取得一个配对出现的div标签，也就是非贪婪模式匹配到的内容，贪婪模式所匹配到的内容通常并不是我们所需要的。

那为什么还要有贪婪模式的存在呢，从应用角度很难给出满意的解答了，这就需要从匹配原理的角度去分析贪婪与非贪婪模式。 

如果想真正了解什么是贪婪模式，什么是非贪婪模式，分别在什么情况下使用，各自的效率如何，那就不能仅仅从应用角度分析，而要充分了解贪婪与非贪婪模式的匹配原理。 

前面提到的非贪婪模式，一直都是使用的“*?”，而没有涉及到其它的区间量词，对于“*?”和“+?”这样的非贪婪模式，大多数接触过正则表达式的人都可以理解，但是对于区间量词的非贪婪模式，比如“{m,n}?”，要么是没见过，要么是不理解，主要是这种应用场景非常少，所以被忽略了。 

首先需要明确的一点，就是量词“{m,n}”是匹配优先量词，虽然它有了上限，但是在达到上限之前，能够匹配，还是要尽可能多的匹配的。而“{m,n}?”就是对应的忽略优先量词了，在可匹配可不匹配的情况下，尽可能少的匹配。 

“??”也是忽略优先量词，被修饰的子表达式使用的也是非贪婪模式，“??”修饰的子表达式，最少匹配0次，最多匹配1次。在匹配过程中，遵循非贪婪模式匹配原则，先不匹配，即匹配0次，记录回溯状态，只有不得不匹配时，才去尝试匹配。

能达到同样匹配结果的贪婪与非贪婪模式，通常是贪婪模式的匹配效率较高。 

所有的非贪婪模式，都可以通过修改量词修饰的子表达式，转换为贪婪模式。 

贪婪模式可以与固化分组结合，提升匹配效率，而非贪婪模式却不可以。

#### 使用圆括号指定分组

现在，我们已经可以实现匹配某个字符串以及丢弃不匹配的字符串，但是有些时候，我们可能会对之前匹配成功的数据更感兴趣。我们不仅想要知道整个字符串是否匹配我们的标准，而且想要知道能否提取任何已经成功匹配的特定字符串或者子字符串。答案是可以，要实现这个目标，只要一对圆括号包裹任何表达式。

当使用正则表达式时，一对圆括号可以实现以下任意一个功能：

* 对正则表达式进行分组；

* 匹配子组

关于为何想要对正则表达式进行分组的一个很好的示例是：当有两个不同的正则表达式而且想用他们来比较同一个字符串的时候。另一个原因是对正则表达式进行分组可以在整个正则表达式中使用重复操作符(而不是一个单独的字符或者字符集)。

使用圆括号进行分组的一个副作用就是，匹配模式的子字符串可以保存起来供后续使用。这些子组能够被同一次的匹配或者搜索反复使用，或者提取出来用于后续处理。

为什么匹配子组这么重要呢？主要原因是在很多时候除了进行匹配操作以外，我们还想要提取所匹配的模式。例如，如果决定匹配模式\w+-\d+，但是想要分别保存第一部分的字母和第二部分的数字，该如何实现？我们可能想要这样做的原因是，对于任何成功的匹配，我们可能想要看到这些匹配正则表达式模式的字符究竟是什么。

如果为两个子模式都加上圆括号，例如（\w+)-(\d+),然后就能够分别访问每一个匹配子组。我们更倾向于使用子组，这时因为择一匹配通过编写代码来判断是否匹配，然后执行另一个单独的程序来解析整个匹配仅仅用于提取两个部分。为什么不让Python自己实现呢？这是re模块支持的一个特性。

#### 扩展表示法

我们还没介绍过的正则表达式的最后一个方面是扩展表达法，它们是以问号开始（?...)。我们不会为此花费太多时间，因为它们通常用于在判断匹配之前提供标记，实现一个前视或者后视匹配，或者条件匹配。尽管圆括号使用这些符号，但是只有(?P<name>) 表述一个分组匹配。所有其他的都没有创建一个分组。

正则表达式模式                   匹配的字符串

(?:\w+\.)*                       以句点作为结尾的字符串，例如“google.”、“twitter.”、“facebook.”，但是这些匹配不
				 会保存下来 供后续的使用和数据检索

(?#comment)                      此处并不做匹配，只是作为注释

(?=.com)                         如果一个字符串后面跟着“.com”才做匹配操作，并不使用任何目标字符串

(?!.net)                         如果一个字符串后面不是跟着“.net”才做匹配操作

(?<=800-)                        如果字符串之前为“800-”才做匹配，假定为电话号码，同样，并不使用任何输入字符串

(?<!192\.168\.)                  如果一个字符串之前不是“192.168.”才做匹配操作，假定用于过滤掉一组 C 类 IP 地址

(?(1)y|x)                        如果一个匹配组 1(\1)存在，就与 y 匹配;否则，就与 x 匹配


## 正则表达式和Python语言

在了解了关于正则表达式的全部知识后，开始查看 Python 当前如何通过使用 re 模块来 支持正则表达式，re模块在古老的Python 1.5版中引入，用于替换那些已过时的regex模块 和 regsub 模块——这两个模块在 Python 2.5 版中移除，而且此后导入这两个模块中的任意一 个都会触发 ImportError 异常。

re模块支持更强大而且更通用的Perl风格(Perl 5风格)的正则表达式，该模块允许多 个线程共享同一个已编译的正则表达式对象，也支持命名子组。

### re 模块:核心函数和方法

----函数/方法----|----描述----

compile(pattern，flags = 0)|使用任何可选的标记来编译正则表达式的模式，然后返回一个正则表达式对象

match(pattern，string，flags=0)|尝试使用带有可选的标记的正则表达式的模式来匹配字符串。如果匹配成功，就返回
匹配对象;如果失败，就返回 None

search(pattern，string，flags=0)|使用可选标记搜索字符串中第一次出现的正则表达式模式。如果匹配成功，则返回匹
配对象;如果失败，则返回 None

findall(pattern，string [, flags] )|查找字符串中所有(非重复)出现的正则表达式模式，并返回一个匹配列表

finditer(pattern，string [, flags] )|与 findall()函数相同，但返回的不是一个列表，而是一个迭代器。对于每一次匹配，迭 代器都返回一个匹配对象

split(pattern，string，max=0)|根据正则表达式的模式分隔符，split 函数将字符串分割为列表，然后返回成功匹配的 列表，分隔最多操作 max 次(默认分割所有匹配成功的位置)

sub(pattern，repl，string，count=0)|使用 repl 替换所有正则表达式的模式在字符串中出现的位置，除非定义 count，否则就 将替换所有出现的位置(另见 subn()函数，该函数返回替换操作的数目)


purge()|清除隐式编译的正则表达式模式

group(num=0)|返回整个匹配对象，或者编号为 num 的特定子组

groups(default=None)|返回一个包含所有匹配子组的元组(如果没有成功匹配，则返回一个空元组)




