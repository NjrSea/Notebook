# 第一章

### 1.4.2 设备驱动

操作系统作为硬件层的上层，它是对硬件的管理和抽象。对于操作系统上面运行库和应用程序来说，它们希望看到的是一个统一的硬件访问模式。作为应用程序的开发者，我们不希望在开发应用时候直接写硬件端口、处理硬件中断等事情。由于硬件之间千差万别，它们的操作方式和访问方式都有区别。比如我们希望在显示器上画一条直线，对于程序员来说，最好的方式是不管计算机使用什么显卡、显示器，我们都只要调用一个统一的lineTo函数，具体实现的方式由操作系统来完成。试想一下如果程序员需要关心具体的硬件，那么结果会是这样：对于A型号的显卡来说，需要往I/O端口0x1001写一个命令0x1111，然后从端口0x1002中读取一个4字节的显存地址，然后使用DDA逐个地在显存上画点，如果是B型号的显卡，可能完全是另一种方式。这简直就是灾难。不过在操作系统成熟之前，的确存在这样的情况，就是应用程序的程序员需要和硬件直接打交道。

当成熟的操作系统出现之后，硬件逐渐被抽象成了一系列概念。在UNIX中，硬件设备的访问形式跟访问普通文件形式一样：在Windows系统中，图形硬件被抽象成了GDI，声音和多媒体设备被抽象成了DirectX对象，等等。程序员逐渐从硬件细节中释放出来，可以更多地关注应用程序本身的开发。这些硬件细节都交给了操作系统，具体地讲是操作系统中的硬件驱动程序来完成。驱动程序可以看做是操作系统的一部分，它往往跟操作系统内核一起运行在特权级，但它又与操作系统意见有一定的独立性，使得驱动程序有比较好的灵活性。因为pc的硬件多如牛毛，操作系统开发者不可能为每一个硬件开发一个驱动程序，这些驱动程序的开发工作通常由硬件生产厂商完成。操作系统开发者为硬件生产厂商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。让我们以一个读取文件为例子来看看操作系统和驱动程序在这个过程中扮演了什么样的角色。

提到文件的读取，那么不得不提到文件系统这个操作系统中最为重要的组成部分之一。文件踢动管理着磁盘中文件的存储方式，比如我们在linux系统下有一个文件/home/user/test.dat，长度为8000个字节。那么我们在创建这个文件的时候，Linux的ext3文件系统有可能将这个文件按照这样的方式存储在磁盘中：文件的前4096字节存储在磁盘的1000号扇区到1007号扇区，每个扇区512字节，8个扇区刚好4096字节：文件的第4097个字节到第8000字节共3904个字节，存储在磁盘的2000号扇区到2007号扇区，8个扇区也是4096字节，不过只存储了3904个有效字节，剩下的192个字节无效。如果把这个文件的存储方式看做一个链装的结构，它的结构如下：


```
这里我们先穿插一个关于硬盘结构的介绍，硬盘基本存储单位为扇区（sector），每个扇区一般为512字节。一个磁盘往往有很多个盘片，每个盘片分两面，每面分为若干个磁道，每个磁道划分为若干个扇区。比如一个硬盘有2个盘片，每个盘片有65536磁道，每个磁道分1024个扇区，那么硬盘的用量就是2 * 2 * 65536 * 1024 * 512 = 128GB。但是我们可以想象，每个盘面上同心圆的周长不一样，如果按照每个磁道都拥有相同数量的扇区，那么靠近盘面外围的密度比内圈要小，这样比较浪费空间。但是如果不同的磁道扇区数不同，计算起来就十分麻烦。为了屏蔽这些硬件细节，现代的硬盘普遍使用一种叫LBA（logical block address）的方式，即整个硬盘中所有的扇区从0号开始，一直到最后一个扇区，这个扇区编号叫做逻辑扇区编号。逻辑扇区编号抛弃了复杂的磁道、盘面之类的概念。当我们给出一个逻辑的扇区号时，磁盘的电子设备会将其转换成实际的盘面、磁道等这些位置。
```

文件系统保存了这些文件的存储结构，负责维护这些数据结构并且保证磁盘中的扇区能够有效地组织和利用。那么当我们在Linux操作系统中，要读取这个文件的前4096个字节时，我们会使用一个read的系统调用来实现。文件系统受到read请求之后，判断出文件的前4096个字节位于磁盘的1000号逻辑扇区到1007号扇区。然后文件系统就向硬盘驱动发出一个读取逻辑扇区1000号开始的8个扇区的请求，磁盘驱动程序受到这个请求以后就向硬盘发出硬件命令。向硬盘发送I/O命令的方式有很多种，其中最常见的一种能就是通过读写I/O端口寄存器来实现。在x86平台上，共有65536个硬件端口寄存器, 不同的硬件被分配到了不同的I/O端口地址。CPU提供了两条专门的指令“in”和“out”来实现对硬件端口的读和写。

对IDE接口来说，它有两个通道，分别为IDE0和IDE1，每个通道上可以连接两个设备，分别为Master和Slave，一个PC钟最多可以有4个IDE设备。假设我们的文件位于IDE0的master硬盘上，这也是正常情况下硬盘所在的位置。在PC中，IDE0通道的I/O端口地址是是0x1f0~0x1f7即0x376~0x377。通过读写这些地址就能与IDE硬盘进行通讯。这些端口的作用和操作方式十分复杂，我们以实现读取1000号逻辑扇区开始的8个扇区为例：

* 第0x1F3~0x1F6 4个字节的端口地址是用来写入LBA地址的，那么1000号逻辑扇区的LBA地址为0x000003e8，所以我们需要往0x1f3、0x1f4写入0x00,往0x1f5写入0x03，往0x1f6写入0xe8。

* 0x1f2这个地址用来写入命令所需要读写的扇区数。比如读取8个扇区即写入8.

* 0x1f7这个地址用来写入要执行的操作的命令吗，对于读取操作来说，命令字为0x20。
所以我们要执行的指令为：

out 0x1f3, 0x00

out 0x1f4, 0x00

out 0x1f5, 0x03

out 0x1f6, 0xe8

out 0x1f2, 0x08

out 0x1f7, 0x20

在硬盘收到这个命令以后，就会执行响应的操作，并且将数据读取到事先设置好的内存地址中（这个内存地址也是通过类似的命令方式设置的）。当然这里的例子中只是最简单的情况，时机情况比这个复杂得多，驱动程序要考虑硬件的状态、调度和分配各个请求以达到最高的性能等。

## 1.5 内存不够怎么办

上面一节我们提到了进程的概念，进程的总体目标是希望每个进程从逻辑上来看都可以独占计算机的资源。操作系统的多任务功能使得cpu能够在多个进程之间很好的共享，从进程的角度看好像是独占了cpu而不用考虑与其他进程分享cpu的事情。操作系统的I/O抽象模型也很好地实现了I/O设备的共享和抽象，那么唯一剩下的就是主存，也就是内存的分配问题了。

在早起的计算机中，程序直接运行在物理内存上，也就是说，程序在运行时所访问的都是物理地址。当然，如果一个计算机同事运行一个程序，那么只要程序要求的内存空间不要超过物理内存的大小，就不会有问题。但是事实上为了更有效地利用硬件资源，我么必须同事运行多个程序，正如前面的多道程序、分析系统和多任务中一样，当我们能够同时运行多个程序是，cpu的利用率将会比较高。那么很明显的一个问题是，如何将计算机上有限的物理内存分配给多个程序使用。

假设我们的计算机有128MB内存。程序A需要10MB,程序B需要100MB，程序C需要20MB。如果我们需要同时运行程序A和B，那么比较直接的做法是将内存的前10MB分配给程序A，10MB~110MB分配给B。这样就能实现A和B两个程序同时运行，但是这种简单的内存分配策略问题很多。

* 地址空间不隔离 左右程序都直接访问物理地址，程序所使用的内存空间不是互相隔离的。恶意的程序可以很容易改写其他程序的内存数据，以达到破坏的目的；有些非恶意的、但是有bug的程序可能不小心修改了其他程序的数据，就会使其他程序也崩溃，这对于需要安全稳定的计算机环境的用户来说是不可容忍的。用户希望他在使用计算机的时候，其中一个任务失败了，至少不会影响其他的任务。

* 内存使用效率低 由于没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装入内存然后开始执行。如果我们忽略需要执行程序c，那么那么这时的内存空间其实已经不够了，这时候我们可以用的一个办法是将其他程序的数据暂时写到磁盘里面，等到需要用到的时候再读回来。由于程序所需要的内存是连续的，那么这个例子里面，如果我们将程序A换出到磁盘所释放的内存空间是不够的，所以只能讲b换出到磁盘，然后将c读入到内存开始运行。可以看到整个过程中有大量的数据在换入换出，导致效率十分低下。

* 程序运行的地taolun程序每次需要装入运行时，我们需要给内存中分配一块足够大的空闲内存区域，这个空闲区域的位置是不确定的。这个程序编写造成了一定的麻烦，因为程序在编写时，它访问数据和命令指令跳转时的目标地址很多都是固定的，这涉及程序的重定位问题，我们在第2部分和第3部分还会详细讨论。

解决这几个问题的思路就是使用我们前文提到的法宝：增加中间层，即使用一种简介的地址访问方法。整个想法是这样的，我们把程序给出的地址看做是一种虚拟地址，然后通过某些映射方法，将这个虚拟地址转换成实际的物理地址。这样，只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能访问的物理内存区域跟另外一个程序互相不重叠，以达到地址空间隔离的效果。

### 1.5.1 关于隔离

让我们回到程序的运行本质上来。用户程序在运行时不希望介入到这些复杂的存储器管理过程中，作为普通的程序，它需要的是一个简单的执行环境，有个单一的地址空间、有自己的CPU，好像整个程序占有整个计算机而不需要关心其他的程序（当然程序间通信的部分除外)，你可以把它想象成一个很大的数组，每个数组的元素是一个字节，而这个数组大小由地址空间的地址长度决定，比如32位的地址空间的大小为2^32字节，即4GB，地址空间有效的地址长度是0~4294967295，用十六进制表示就是0x00000000~0xFFFFFFF。地址空间分两种：虚拟地址空间和物理地址空间。物理地址空间实实在在存在，存在于计算机中，而且对于每一台计算机来说只有唯一的一个，你可以把物理空间想象成物理内存，比如你的计算机用的intel处理器，那么它是32位的机器，即计算机地址线有32条（实际上有36条地址线），那么物理空间就有4GB。但是你的计算机上只装了512MB的内存，那么其实物理地址的真正有效部分只有0x00000000~0x1FFFFFFF,其他部分都是无效的（实际上还有一些外部I/O设备映射到物理空间的，也是有效的。但是我们暂时无视其存在）。虚拟地址空间指虚拟的、人们想象出来的地址空间，其实它并不存在，每个进程都有自己独立的虚拟空间，而且每个进程只能访问自己的地址空间，这样就有效地做到了进程的隔离。

### 1.5.2 分段

最开始人们使用的是一种叫分段的方法，基本思路是把一段与程序所需要的内存空间大小的虚拟地址映射到某个地址空间。比如程序A需要10MB内存，那么我们假设有一个地址从0x00000000到0x00A00000的10MB大小的一个假象的空间，也就是虚拟空间，然后我们从实际的物理内存中分配一个相同大小的物理地址，假设是物理地址0x00100000开始到0x00B00000结束的一块空间。然后我们把这两块相同大小的地址空间一一映射，即虚拟空间中的每个字节相对应与物理空间的每个字节。这个映射过程由软件来设置，比如操作系统来设置这个映射函数，时机的地址转换由硬件完成。比如当程序A中访问地址0x00001000时，CPU会将这个地址转换成实际的物理地址0x00101000。那么比如程序A和程序B在运行时，它们的虚拟地址和物理空间映射关系可能如下：

分段的方法基本解决了上面提到的3个问题中的第一个和第三个，它们之间没有任何重叠，如果程序A访问虚拟哦空间的地址超出了0x00A00000这个范围，那么硬件就会判断这是一个非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或监控程序，由它来决定如何处理。再者，对于每个程序来说，无论他们被分配到了物理地址的哪一个区域，对于程序来说都是透明的，他们不需要关心物理地址的变化，他们只需要按照从地址0x00000000到0x00A000000来编写程序、放置变量，所以程序不再需要重定位。


