# 第三章 网络客户端编程

第 2 章介绍了使用套接字的底层网络通信协议。这种类型的网络是当今因特网中大部分 客户端/服务器协议的核心。这些网络协议分别用于文件传输(FTP、SCP 等)、阅读 Usenet 新闻组(NNTP)、发送电子邮件(SMTP)、从服务器上下载电子邮件(POP3、IMAP)等。 协议的工作方式与第 2 章介绍的客户端/服务器的例子相似。唯一区别在于现在使用 TCP/IP 这样底层的协议创建了新的、有专门用途的协议，以此来实现刚刚介绍的高层服务。

***

## 文件传输

因特网中最常见的事情就是传输文件。文件传输每时每刻都在发生。有很多协议可以用 于在因特网上传输文件。最流行的包括文件传输协议(FTP)、UNIX 到 UNIX 复制协议 (UUCP)、用于 Web 的超文本传输协议(HTTP)。另外，还有(UNIX 下的)远程文件复制
命令 rcp(以及更安全、更灵活的 scp 和 rsync)。
在当下，HTTP、FTP、scp/rsync 的应用仍然非常广泛。HTTP 主要用于基于 Web 的文件
下载以及访问 Web 服务，一般客户端无须登录就可以访问服务器上的文件和服务。大部分 HTTP 文件传输请求都用于获取网页(即将网页文件下载到本地)。

而 scp 和 rsync 需要用户登录到服务器主机。在传输文件之前必须验证客户端的身份，否则 不能上传或下载文件。FTP 与 scp/rsync 相同，它也可以上传或下载文件，并采用了 UNIX 的多 用户概念，用户需要输入有效的用户名和密码。但 FTP 也允许匿名登录。现在来深入了解 FTP。

### 文件传输协议

文件传输协议(File Transfer Protocol，FTP)由已故的 Jon Postel 和 Joyce Reynolds 开发， 记录在RFC(Request for Comment)959号文档中，于1985年10月发布。FTP主要用于匿 名下载公共文件，也可以用于在两台计算机之间传输文件，特别是在使用 Windows 进行工作， 而文件存储系统使用 UNIX 的情况下。早在 Web 流行之前，FTP 就是在因特网上进行文件传 输以及下载软件和源代码的主要手段之一。

前面提到过，FTP 要求输入用户名和密码才能访问远程 FTP 服务器，但也允许没有账号的 用户匿名登录。过管理员要先设置 FTP 服务器以允许匿名用户登录。这时，匿名用户的用户 名是“anonymous”，密码一般是用户的电子邮件地址。与向特定的登录用户传输文件不同，这 相当于公开某些目录让大家访问。但与登录用户相比，匿名用户只能使用有限的几个 FTP 命令。

图 3-1 展示了这个协议，其工作流程如下。

1)客户端连接远程主机上的 FTP 服务器。

2)客户端输入用户名和密码

3)客户端进行各种文件传输和信息查询操作

4) 客户端从远程 FTP 服务器退出，结束传输

当然，这只是一般情况下的流程。

在底层，FTP 只使用 TCP(见第 2 章)，而不使用 UDP。另外，可以将 FTP 看作客户 端/服务器编程中的特殊情况。因为这里的客户端和服务器都使用两个套接字来通信:一个 是控制和命令端口(21 号端口)，另一个是数据端口(有时是 20 号端口)，如图 3-1 所示。

前面说“有时”是因为 FTP 有两种模式:主动和被动。只有在主动模式下服务器才使用 数据端口。***在服务器把 20 号端口设置为数据端口后，它“主动”连接客户端的数据端口。而 在被动模式下，服务器只是告诉客户端随机的数据端口号，客户端必须主动建立数据连接。***

在这种模式下，FTP 服务器在建立数据连接时是“被动”的。最后，现在已经有了一种扩展 的被动模式来支持第 6 版本的因特网协议(IPv6)地址——详见 RFC 2428。

Python 已经支持了包括 FTP 在内的大多数据因特网协议。可以在 http://docs.python. org/lib/internet.html 中找到支持各个协议的客户端模块。现在看看用 Python 创建因特网客户 端程序有多么容易。

### Python 和 FTP

那么如何用 Python 编写 FTP 客户端程序呢?其实之前已经提到过一些了，现在还要添 加相应的 Python 模块导入和调用操作。再回顾一下流程。

1) 连接到服务器

2) 登录

3) 发送服务请求（希望能得到相应）

4) 退出

在使用Python的ftp支持时，所有要做的只是导入ftplib模块，并实例化一个ftplib.FTP类对象。所有的 FTP 操作(如登录、传输文件和注销等)都要使用这个对象完成。

下面是一段 Python 伪代码。

```
from ftplib import FTP

f = FTP('some.ftp.server')

f.login('anonymous', 'your@email.address')
...
f.quit()
```

### ftplib.FTP 类的方法

----|----
方法|描述
login(user='anonymous', passwd='', acct='')|登录 FTP 服务器，所有参数都是可选的

pwd()|获得当前工作目录

cwd(path)|把当前工作目录设置为 path 所示的路径

dir ([path[,...[,cb]])|显示 path 目录里的内容，可选的参数 cb 是一个回调函数，会传递给 retrlines()方法

nlst ([path[,...])|与 dir()类似，但返回一个文件名列表，而不是显示这些文件名

retrlines(cmd [, cb])|给定 FTP 命令(如“RETR filename”)，用于下载文本文件。可选的回调函数 cb 用于处理文件的每一行

retrbinary(cmd,
cb[,bs=8192[, ra]])| 与 retrlines()类似，只是这个指令处理二进制文件。回调函数 cb 用于处理每一块(块大小默认为 8KB) 下载的数据

storlines(cmd, f)|给定 FTP 命令(如“STOR filename”)，用来上传文本文件。要给定一个文件对象 f

storbinary(cmd, f [,bs=8192])|与 storlines()类似，只是这个指令处理二进制文件。要给定一个文件对象 f，上传块大小 bs 默认为 8KB

rename(old, new)|把远程文件 old 重命名为 new

delete(path)|删除位于path的文件

mkd(directory)|创建远程目录
rmd(directory)|删除远程目录 
quit()|关闭连接并退出

在一般的 FTP 事务中，要使用到的指令有 login()、cwd()、dir()、pwd()、stor*()、retr*() 和 quit()。表 3-1 中没有列出的一些 FTP 对象方法也很有用。关于 FTP 对象的更多信息，请 参阅 http://docs.python.org/library/ftplib#ftp-objects 中的 Python 文档。

在 Python 中使用 FTP 非常简单，甚至都不用写脚本，直接在交互式解释器中就能实时 地看到操作步骤和输出。下面这个示例会话是在几年前 python.org 还支持 FTP 服务器的时候 做的。现在这个示例已经无法工作，只是用来演示与正在运行的 FTP 服务器进行交互的情形。

```
>>> from ftplib import FTP
>>> f = FTP('ftp.python.org')
>>> f.login('anonymous', 'guido@python.org') '230 Guest login ok, access restrictions apply.' >>> f.dir()
total 38
drwxrwxr-x 10 1075
drwxrwxr-x 10 1075
drwxr-xr-x 3 root
drwxr-sr-x 3 root
drwxr-xr-x 3 root
lrwxrwxrwx 1 root
-r--r--r-- 1 guido
drwxrwsr-x 8 1122
drwxr-xr-x 5 root
>>> f.retrlines('RETR motd')
Sun Microsystems Inc. SunOS 5.6
'226 Transfer complete.
>>> f.quit()
'221 Goodbye.'
```

### 客户端 FTP 程序示例

前面提到过，如果直接在交互环境中使用 FTP 就无须编写脚本。但下面还是编写一段脚 本，用来从 Mozilla 的网站下载最新的 Bugzilla 代码。示例 3-1 就用来完成这个工作。虽然这 里在尝试编写一个应用程序，但读者也可以交互式地运行这段代码。这个程序使用 FTP 库下 载文件，其中也包含一些错误检查。

```
#!/usr/bin/env python

import ftplib
import os
import socket

HOST = 'ftp.mozilla.org'
DIRN = 'pub/mozilla.org/webtools'
FILE = 'bugzilla-LATEST.tar.gz'

def main():
    try:
       f = ftplib.FTP(HOST)
    excpt (socket.error, socket.gaierror) as e:
       print('ERROR: cannot reach "%s"' % HOST
       return
    
    ....
```

不过脚本并不会自动运行，需要手动运行才会下载代码。如果使用的是类 UNIX 系统， 可以设定一个 cron 作业来自动下载。另一个问题是，如果需要下载的文件的文件名或目录名 被修改了，程序就无法正常工作。

以下是一些典型的 FTP 客户端类型。

* 命令行客户端程序:使用一些 FTP 客户端程序(如/bin/ftp 或 NcFTP)进行 FTP 传
输，用户可以在命令行中交互式执行 FTP 传输。

* GUI 客户端程序:与命令行客户端程序相似，但它是一个 GUI 程序，如 WS_FTP、
Filezilla、CuteFTP、Fetch、SmartFTP。

* Web 浏览器:除了使用 HTTP 之外，大多数 Web 浏览器(也称为客户端)可以进行 FTP
传输。URL/URI 的第一部分就用来表示所使用的协议，如“http://blahblah”。这就告诉浏 览器要使用 HTTP 作为与指定网站传输数据的协议。通过修改协议部分，就可以发送使 用 FTP 的请求，如“ftp://blahblah”，这与使用 HTTP 的网页 URL 很像(当然，“ftp://” 后面的“blahblah”可以展开为“host/path?attributes”)。如果要登录，用户可以把登录信 息(以明文方式)放在URL里，如:“ftp://user:passwd@host /path?attr1=val1&attr2=val2. . .”。

* 自定义应用程序:自己编写的用于 FTP 文件传输的程序。这些是用于特殊目的的应 用程序，一般这种程序不允许用户与服务器交互。


***

## 网络新闻

Usenet 新闻系统是一个全球存档的“电子公告板”。各种主题的新闻组一应俱全，从诗 歌到政治，从自然语言学到计算机语言，从软件到硬件，从种植到烹饪、招聘/应聘、音乐、 魔术、相亲等。新闻组可以面向全球，也可以只面向某个特定区域。


整个系统是一个由大量计算机组成的庞大的全球网络，计算机之间共享 Usenet 上的帖 子。如果某个用户发了一个帖子到本地的 Usenet 计算机上，这个帖子会被传播到其他相连 的计算机上，再由这些计算机传到与它们相连的计算机上，直到这个帖子传播到了全世界， 每个人都收到这个帖子为止。帖子在 Usenet 上的存活时间是有限的，这个时间可以由 Usenet 系统管理员来指定，也可以为帖子指定一个过期的日期/时间。

每个系统都有一个已“订阅”的新闻组列表，系统只接收感兴趣的新闻组里的帖子，而不是 接收服务器上所有新闻组的帖子。Usenet 新闻组的内容由提供者安排，很多服务都是公开的。但 也有一些服务只允许特定用户使用，例如付费用户、特定大学的学生等。Usenet 系统管理员可能 会进行一些设置来要求用户输入用户名和密码，管理员也可以设置是否只能上传或只能下载。

Usenet 正在逐渐退出人们的视线，主要被在线论坛替代。但依然值得在这里提及，特别 是它的网络协议。老的 Usenet 使用 UUCP 作为其网络传输机制，在 20 世纪 80 年代中期出现了另一个网络 协议 TCP/IP，之后大部分网络流量转向使用 TCP/IP。下一节将介绍这个新的协议。

### 网络新闻传输协议

用户使用网络新闻传输协议(NNTP)在新闻组中下载或发表帖子。该协议由 Brain Kantor (加州大学圣地亚哥分校)和 Phil Lapsley(加州大学伯克利分校)创建并记录在 RFC 977 中，
于 1986 年 2 月公布。其后在 2000 年 10 月公布的 RFC 2980 中对该协议进行了更新。 作为客户端/服务器架构的另一个例子，NNTP 与 FTP 的操作方式相似，但更简单。在 FTP 中，登录、传输数据和控制需要使用不同的端口，而 NNTP 只使用一个标准端口 119 来
通信。用户向服务器发送一个请求，服务器就做出相应的响应，如图 3-2 所示。


### Python 和 NNTP

由于之前已经有了 Python 和 FTP 的经验，读者也许可以猜到，有一个 nntplib 库和一个 需要实例化的 nntplib.NNTP 类。与 FTP 一样，所要做的就是导入这个 Python 模块，然后调 用相应的方法。先大致看一下这个协议。

1)连接到服务器。

2)登录(根据需要)。

3)发出服务请求。

4)退出。

是不是有点熟悉?是的，这与 FTP 协议极其相似。唯一的区别是根据 NNTP 服务器配置的不同，登录这一步是可选的。

***

## 电子邮件

电子邮件既古老又现代。对于作者这些很早之前就开始使用因特网的人来说，电子邮件 看上去都非常“古老”，更不用说与今日基于网页的在线聊天、即时聊天(IM)、数字电话(如 VoIP[Voice over Internet Protocol])等更新、更快的通信方式相比了。下面将从宏观上介绍 一下电子邮件是如何工作的。如果读者已经了解相关内容，只想学习用 Python 做电子邮件相 关的开发，可以跳到下一节。

在介绍电子邮件的基础架构之前，读者是否真正了解电子邮件的确切定义呢?根据 RFC 2822 的定义，“(电子邮件)消息由头字段(统称消息标题)以及后面可选的正文组成”。 对于一般用户来说，一说起电子邮件，无论是一封真的邮件，还是一封不请自来的商业广 告(即垃圾邮件)，都会想到邮件正文。不过 RFC 规定，邮件可以没有正文，但一定要有 邮件标题，这一点要特别注意。

### 电子邮件系统组件和协议

不管读者是怎么认为的，实际上电子邮件诞生在现代因特网出现之前。电子邮件一开始 用于在不同主机用户之间简单交换消息。注意，因为这些用户都使用同一台计算机，所以这 里还没有涉及网络。在网络出现之后，用户就可以在不同的主机之间交换消息。当然，由于 用户使用不同的计算机，计算机之间使用不同的协议，消息交换是一个很复杂的概念。直到 20 世纪 80 年代，因特网上收发电子邮件才有一个事实上的统一标准。

在深入细节之前，不禁想问，电子邮件是怎么工作的?一条消息是如何从发件人那里通 过浩瀚的因特网到达收件人的?简单点来说，有一台发送计算机(发件人的消息从这里发送 出去)和一台接收计算机(收件人的邮件服务器)。最好的解决方案是发送计算机知道如何连 接到接收计算机，这样就可以直接把消息发送过去。但实际上一般没有这么顺利。

发送计算机需要找到某一台中间主机，而这台中间主机最终能到达最后的接收主机。接 着这台中间主机需要找到一台离接收主机更近一些的主机。所以，在发送主机和接收主机之 间，可能会有多台称为跳板的主机。如果仔细看看收到的电子邮件消息头标题，会看到一个
“护照”标记，其中记录了这封邮件最终抵达之前，一路上都到过哪些地方。

为了更清楚地理解，先看看电子邮件系统的各个组件。最重要的组件是消息传输代理 (MTA)。这是在邮件交换主机上运行的服务器进程，它负责邮件的路由、队列处理和发送工 作。MTA 就是邮件从发送主机到接收主机所要经过的主机和“跳板”，所以也称为“消息传
输”的“代理”。

为了更清楚地理解，先看看电子邮件系统的各个组件。最重要的组件是消息传输代理 (MTA)。这是在邮件交换主机上运行的服务器进程，它负责邮件的路由、队列处理和发送工 作。MTA 就是邮件从发送主机到接收主机所要经过的主机和“跳板”，所以也称为“消息传
输”的“代理”。

要让所有这些工作起来，MTA 要知道两件事情:1)如何找到消息应该到达的下一台MTA;2)如何与另一台 MTA 通信。第一件事由域名服务(DNS)来查找目的域名的 MX(Mail
eXchange，邮件交换)来完成。查找到的可能不是最终收件人，而可能只是下一个能最终把
消息送到目的地的主机。对于第二件事，MTA 怎么把消息转给其他的 MTA 呢?

### 发送电子邮件

为了发送电子邮件，邮件客户端必须要连接到一个 MTA，MTA 靠某种协议进行通信。MTA 之间通过消息传输系统(MTS)互相通信。只有两个 MTA 都使用这个协议时，才能进行通信。 在本节开始时就说过，由于以前存在很多不同的计算机系统，每个系统都使用不同的网络软件， 因此这种通信很危险，具有不可预知性。更复杂的是，有的计算机使用互连的网络，而有的计 算机使用调制解调器拨号，消息的发送时间也是不可预知的。事实上，作者曾经有一封邮件在 发送 9 个月后才收到!因特网的速度怎么会这么慢?这种复杂性导致了现代电子邮件的基础之 一 ——简单邮件传输协议(Simple Mail Transfer Protocol，SMTP)的诞生。

1)SMTP、ESMTP、LMTP

SMTP 原先由已故的 Jonathan Postel(加州大学信息学院)创建，记录在 RFC 821 中，于 1982 年 8 月公布，其后有一些小修改。在 1995 年 11 月，通过 RFC 1869，SMTP 增加了一些 扩展服务(即EXMTP)，现在 STMP和ESMTP都合并到当前的RFC5321中，于2008年10 月公布。这里使用 STMP 同时表示 SMTP 和 ESMTP。对于一般的应用，只要能登录服务器、 发送邮件、退出即可。这些都很基础。

还有其他的协议，如 LMTP(Local Mail Transfer Protocol，本地邮件传输协议)，其基于 SMTP和ESMTP，作为RFC 2033于1996年10月定义。SMTP需要有一个邮件队列，但这 需要额外的存储和管理工作。而 LMTP 提供了更轻量级的系统，移除了对邮件队列的需求。 但邮件需要立即发送(即不会入队)。LMTP 服务器不暴露到外面直接与连接到因特网的邮件 网关工作，以表示接收还是拒绝一条消息。而网关作为 LMTP 的队列。

2)MTA

一些实现 SMTP 的著名 MTA 包括以下几个。 开源 MTA

* Sendmail
* Postfix
* Exim
* qmail

商业 MTA

* Microsoft Exchange
* Lotus Notes Domino Mail Server

注意，虽然这些都实现了最小的 SMTP 协议需求，但其中大多数，尤其是一些商业 MTA， 都在服务器中加入了协议定义之外的特有功能。

SMTP 是在因特网上的 MTA 之间消息交换的最常用 MTSMTA。用 SMTP 把电子邮件从 一台(MTA)主机传送到另一台(MTA)主机。 发电子邮件时，必须要连接到一个外部 SMTP 服务器，此时邮件程序是一个 SMTP 客户端。而 SMTP 服务器也因此成为消息的第一站。

***

### Python 和 SMTP

是的，也有一个 smtplib 模块和一个需要实例化的 smtplib.SMTP 类。先回顾这个已经熟 悉的过程。

1.连接到服务器。 2.登录(根据需要)。 3.发出服务请求。 4.退出。

像 NNTP 一样，登录是可选的，只有在服务器启用了 SMTP 身份验证(SMTP-AUTH) 时才要登录。SMTP-AUTH在RFC 2554中定义。还是与NNTP一样，SMTP通信时只要一 个端口，这里是端口号 25。
下面是一些 Python 伪代码。

from smtplib import SMTP
n = SMTP('smtp.yourdomain.com') ...
n.quit()

### smtplib.SMTP 类方法 

除了 smtplib.SMTP 类之外，Python 2.6 还引入了另外两个类，即 SMTP_SSL 和 LMTP。 后者实现了 LMTP(如 3.4.2 节所述)。前者的作用类似 SMTP，如 3.4.2 节所述，但通过加密 的套接字通信，可以作为 SMTP/TLS 的替代品。STMP_SSL 默认端口是 465。

sendmail()的所有参数都要遵循RFC 2822，即电子邮件地址必须要有正确的格式，消息 正文要有正确的前导标题，正文必须由回车和换行符(\r\n)对分隔。

注意，实际的消息正文不是必需的。根据RFC 2822，“唯一需要的消息标题只有发送日 期字段和发送地址字段”，即“Date:”和“From:”(MAIL FROM、RCPT TO、DATA)。

表 3-3 列出了一些常见的 SMTP 对象方法。还有一些方法没有提到，不过一般来说，其他方 法在发送电子邮件时用不到。关于 SMTP 对象的所有方法的更多信息，可以参见 Python 文档。

----|----
方法|描述
sendmail(from, to, msg[, mopts, ropts])|

ehlo()或 helo()|使用 EHLO 或 HELO 初始化 SMTP 或 ESMTP 服务器的会话。这是可选的，因为
	 	sendmail()会在需要时自动调用相关内容

starttls(keyfile=None, certfile=None)|让服务器启用 TLS 模式。如果给定了 keyfile 或 certfile，则它们用来创建安全套接字

set_debuglevel(level)|为服务器通信设置调试级别

quit()|关闭连接并退出

login(user, passwd)|使用用户名和密码登录 SMTP 服务器(只用于 SMTP-AUTH)


***

### SMTP 的其他内容

关于SMTP的更多信息可以阅读SMTP协议定义/规范，即RFC 5321，参见http://tools. ietf.org/html/rfc2821。关于 Python对SMTP的更多支持，可以阅读http://docs.python.org/library /smtplib。
关于电子邮件，还有一个很重要的方面没有讨论，即如何正确设定因特网地址的格式和 电子邮件消息。这些信息详细记录在最新的因特网消息格式规范(RFC 5322)中。可以访问 http://tools.ietf.org/html/rfc5322 来了解。

关于电子邮件，还有一个很重要的方面没有讨论，即如何正确设定因特网地址的格式和 电子邮件消息。这些信息详细记录在最新的因特网消息格式规范(RFC 5322)中。可以访问 http://tools.ietf.org/html/rfc5322 来了解。

在以前，只有大学生、研究人员和工商企业的雇员会在因特网上用电子邮件通信。那时台 式机还都是装有类 UNIX 操作系统的工作站。而家庭用户主要是在 PC 上拨号上网，并没有用 到电子邮件。在 20 世纪 90 年代中期因特网大爆炸的时候，电子邮件才开始进入千家万户。

对于家族用户来说，在家里放一个工作站来运行 SMTP 是不现实的，因此必须要设计一 种新的系统，能够周期性地把邮件下载到本地计算机，以供离线时使用。这样的系统就要有 一套新的协议和新的应用程序来与邮件服务器通信。

这种在家用电脑中运行的应用程序叫邮件用户代理(Mail User Agent，MUA)。MUA 从 服务器上下载邮件，在这个过程中可能会自动删除它们(也可能不删除，留在服务器上，让 用户手动删除)。不过 MUA 也必须要能发送邮件。也就是说，在发送邮件的时候，应用程序 要能直接使用 SMTP 与 MTA 进行通信。在前面介绍 SMTP 的小节中已经看过这种发送邮件 的客户端了。那下载邮件的客户端呢?

### POP 和 IMAP

第一个用于下载邮件的协议称为邮局协议(Post Office Protocal，POP)，记录在RFC 918 中，于 1984 年 10 月公布，“邮局协议(POP)的目的是让用户的工作站可以访问邮箱服务器 里的邮件，并在工作站中。通过简单邮件传输协议(SMTP)将邮件发送到邮件服务器”。POP 协议的最新版本是第 3 版，也称为 POP3。POP3 在 RFC 1939 中定义，至今仍在广泛应用。

在 POP 出现几年之后有了一个与之竞争的协议，即因特网消息访问协议(Internet Message Access Protocol，IMAP)。IMAP还有其他名称，如“因特网邮件访问协议”、“交 互式邮件访问协议”、“临时邮件访问协议”。第 1 版的 IMAP 是实验性质的，直到第2版才 公布其 RFC(于 1988 年 7 月发布的 RFC 1064)。RFC 1064 中指出，IMAP2 受到了 POP 第 2版(POP2)的启发。

IMAP 旨在提供比 POP 更完整的解决方案，但它也因此比 POP 更复杂。例如，IMAP 非 常适合今天的需要，因为用户需要通过不同的设备使用电子邮件，如台式机、笔记本电脑、 平板电脑、手机、视频游戏系统等。POP 无法很好地应对多邮件客户端，尽管 POP 应用依然 广泛，但大部分情况下已经被废弃了。注意，许多 ISP 当前只提供 POP 来接收(用 SMTP 发 送)邮件。希望今后 IMAP 能得到更多应用。

IMAP 旨在提供比 POP 更完整的解决方案，但它也因此比 POP 更复杂。例如，IMAP 非 常适合今天的需要，因为用户需要通过不同的设备使用电子邮件，如台式机、笔记本电脑、 平板电脑、手机、视频游戏系统等。POP 无法很好地应对多邮件客户端，尽管 POP 应用依然 广泛，但大部分情况下已经被废弃了。注意，许多 ISP 当前只提供 POP 来接收(用 SMTP 发 送)邮件。希望今后 IMAP 能得到更多应用。

当前广泛使用的版本是 IMAP4rev1。实际上，Microsoft Exchange 这个当今最主要的邮件 服务器使用IMAP作为下载方式。在编写本书时，最新的IMAP4rev1协议草案是RFC 3501
(公布于 2003 年 3 月)。本书中的 IMAP4 同时表示 IMAP4 和 IMAP4rev1 协议。

要了解更多内容，建议查阅前面提到的 RFC 文档。图 3-3 显示了电子邮件这个复杂的系统。 现在进一步了解 Python 中对 POP3 和 IMAP4 的支持。


