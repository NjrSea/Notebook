# 第4章 基本TCP套接字编程

## 4.1 概述

本章讲解编写一个完整的TCP客户/服务器程序所需要的基本套接字函数。讲解完即将使用的所有基本套接字函数之后，我们将在下一张开发一个客户/服务器程序。 我们将围绕该程序展开本书，并多次对它加以改进。

我们还讲解并发服务器，它是在同时有大量客户的连接到同一服务器上时使用于提供并发性的一种常见Unix技术。每个客户端连接都迫使服务器fork一个新的进程。本章中我们只考虑使用fork实施的每个客户单进程模型，然而当在第26张讨论线程时，我们将考虑称为没客户单线程的另外一种模型。

图4-1给出了在一对TCP客户与服务器进程之间发生的一些典型事件的时间表。服务器首先启动，稍后某个时刻客户端启动，它试图连接到服务器。我们假设客户端给服务器发送一个请求，服务器处理该请求，并且给客户发回一个响应。这个过程一直持续下去，知道客户关闭连接的客户端，从而给服务器发送一个EOF通知为止。服务器接着也关闭连的服务器端，然后结束运行或者等待新的客户连接。

## 4.2 socket函数

为了执行网络I/O，一个进程必须做的第一件事情就是调用socket函数，制定期望的通信协议类型（使用IPv4的TCP、使用IPv6的UDP、Unix域字节流协议等）。

```
#include <sys/socket.h>

int socket(int family, int type, int protocol); /* 返回：若成功则为非负描述符，若出错则为-1 */
```

其中family参数指明协议族，它是图4-2所示的某个常值。该参数也往往被称为协议域。type参数指明套接字类型，它是图4-3中所示的某个常值。porotocol参数应设为图4-4所示的某个协议类型常值，或者设为0，以选择所给定family和type组合的系统默认值。

并非所有套接字family和type的组合都是有效的，图4-5给出了一些有效的组合和对应的真正协议。其中标为“是”的项也是有效的，但是还没有便捷的缩略词。而空白项则是无效组合。

```
你可能还会碰到作为socket函数第一参数的相应的PF_xxx常值，我们在本节末讲解。你也许会碰到AF_LOCAL被代之为AF_UNIX，在第15章中我们再做详细说明。

参数family和type还有其他值。例如4.4BSD支持的family参数值还有AF_NSS和AF_ISO（OSI协议），不过现在很少有人使用这些协议。

Xerox NS协议和OSI协议都实现了对SOCK_SEQPACKET这个type参数值的支持，我们将在9.2节讲解该值在SCTP中的使用。然而TCP是一个字节流协议，仅支持SOCK_STREAM套接字。

Linux支持一个新的套接字类型SOCK_PACKET，它与图2-1中的BPF和DLPI类似，支持对数据链路的访问，具体将在第29张中叙述。

密钥套接字AF_KEY比较新，用于支持基于加密的安全性。跟路由套接字（AF_ROUTE）是内核中路由表的接口这种方式类似，密钥套接字是与内核中密钥表的接口。密钥套接字在第19章中讲解。
```

socket函数在成功时返回一个小的非负整数值，它与文件描述符类似，我们把它称为套接字描述符（socket descriptor），简称sockfd。为了得到这个套接字描述符，我们只是制定了协议族和套接字类型。我们并没有制定本地协议地址或远程协议地址。

***对比AF_XXX和PF_XXX***

AF_前缀表示地址族，PF_前缀表示协议族。历史上曾有这样的想法：单个协议族可以支持多个地址族，PF_值用来创建套接字，而AF——值用于套接字地址结构。但实际上，支持多个地址族的协议族从来就未实现过，而且头文件<sys/socket.h>中为一给定协议定义的PF_值总是与此协议的AF_值相等。尽管这种相等关系并不一定永远成立，但若有人试图给已有的协议改变这种约定，则许多现存代码都将崩溃。为与现存代码保持一致，本书中我们仅使用AF_常值，尽管在调用socket时我们可能会碰到PF_值。

```
查看BSD/OS 2.1版本中调用socket的137个程序，可以发现，有143个调用指定AF_值，仅有8个调用指定PF_值。

从历史上说，AF_前缀与PF_前缀具有相似常值集的原因要追溯到4.1cBSD和必我们正讲解的(随4.2BSD出现的）socket函数早些的一个版本。socket函数的4.1cBSD版本采用了四个参数，其中有一个是指向sockproto结构的指针。该结构的第一个成员名为sp_family，它的值是某个PF_值；第二个成员即sp_protocol是一个协议号，与现行socket函数的第三个参数类似。指定协议族的唯一方式就是指定该结构，因此，在这个早期系统结构中，PF_值用来在sockproto结构中指定协议族的结构标签，而AF_值用来在套接字地址结构中指定地址族的结构标签。4.4BSD中仍有sockproto结构，但仅由内核在内部使用。在最初的定义中，对sp_family成员有“protocol family”（协议族）的注释，在4.4BSD源码中已改为“address family”(协议族)了。

让人更弄不清AF_常值和PF_之间区别的是，其中有成员可与socket函数的第一个参数作比较的Berkeley内核数据结构（domain结构的dom_family成员）有这样的注释：它含有AF_值。尽管如此，内核中有些domain结构被初始化为相应的AF_值，而其他的domain结构则被初始化为PF_值。

作为另一个历史注解，4.2BSD中socket函数的手册页面将该函数的第一个参数称为af，并把它的可能取值作为AF_常值列出。

最后，我们指出POSIX规范指定socket函数的第一个参数为PF_值，而AF_值用于套接字地址结构。然而它在addrinfo结构中却只定义了一个族值，即用于调用socket函数，也用于套接字地址结构中。
```

## 4.3 connect函数

TCP客户用connect函数来建立与TCP服务器的连接。

```
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen); /* 若成功则返回0，若出错为-1 */
```

sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小，如3.3节所述。套接字地质结构必须函数服务器的IP地址和端口号。我们已经在图1-5中见过本函数的一个例子。

客户在调用函数connect前不必非得调用bind函数，因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。

如果是tcp套接字，调用connect函数将激发tcp的三路握手过程，而且仅在连接建立成功或出错时才会返回，其中出错返回可能有以下几种情况。

（1）若tcp客户没有收到syn分节的响应，则返回etimedout错误。举例来说，调用connect函数时，4.4bsd内核发送一个syn，若无响应则等待6s后再发送一个，若仍无响应则等待24s后再发送一个。若总共等了75s后仍未收到响应则返回本错误。

有些系统提供对超时值的管理型控制。

（2）若对客户的syn的响应是rst（表示复位），则表明该服务器主机在我们指定的端口上没有进程在等待与之连接(例如服务器进程也许没有在运行).这是一种应错误（hard error），客户一接受到rst就马上返回ECONNREFUSED错误。

rst是tcp在发生错误时发送的一种tcp分节。产生rst的三个条件是：目的地为某端口的syn到达，然而该端口上没有正在监听的服务；tcp想取消一个已有连接；tcp接受到一个根本不错在的连接上的分节。

（3）若客户发出的syn再中间的某个路由器上引发了一个“destination unreachable”ICMP错误，则认为是一种软错误。客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送syn。若在某个规定时间（4.4bsd规定75s）后仍未收到响应，则把保存的消息（即ICMP错误）作为EHOSTUNREACH或ENETUNREACH错误返回给进程。以下两种情形也是有可能的：一是按照本地系统的转发表，根本没有到达远程系统的路径；二是connect调用根本不等待就返回。

```
许多早期系统在收到“目的地不可达”ICMP错误时会不正确地放弃建立连接的尝试。这种做法不正确是因为ICMP错误可能指示某个暂停状态。譬如说，它可能是终究可以修复的某个路由问题引起的。

注意，及时ICMP错误指示目的网络不可达，图A-15中也没有列出ENETUNREACH。网络不可达的错误被认为已过时，应用程序应该把ENETUNREACH和EHOSTUNREACH作为相同的错误对待。
```

我们可以用图1-5所示的简单客户程序来查看这些不同的出错情况。首先指定本地主机(127.0.0.1）,它正在运行对应的时间获取程序，我们观察正常的输出：

为了查看返回响应的另一种格式，我们指定另外一个主机的IP地址：

我们接着指定本地子网（192.168.1/24）上其主机ID并不存在的一个IP地址，也就是说本地子网上没有一个主机ID为100的主机，这样当客户主机发出arp请求（要求那个不存在的主机响应以其硬件地址)时，它将永远收不到arp请求.


我们等到connect函数超时后才得到该错误。留意我们的err_sys函数以直观刻度的字符串消息显示了ETIMEDOUT错误的含义。

下一个例子中我们指定一个没有运行时间获取服务器程序的主机（其实是一个本地路由器）。

服务器立刻响应以一个RST分节。

最后一个例子中我们指定一个因特网中不可到达的IP地址。如果我们用tcpdump观察分组的情况，就会发现6跳以远的路由器反回了主机不可到达的ICMP错误。

跟ETIMEDOUT错误一样，本例中的connect也在等待规定的一段时间之后才返回EHOSTUNREACH错误。

按照TCP状态转换图，connect函数导致当前套接字从CLOSED状态转移到SYN_SENT状态，若成功则再转移到ESTABLISHED状态。若connect失败则该套接字不在可用，必须关闭，我们不能对这样的套接字在此调用connect函数。在图11-10中我们将看到，当循环调用函数connect为给定主机尝试各个IP地址知道有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket。

## 4.4 bind 函数

bind函数把一个本地协议地址赋予一个套接字。对于网际网协议，协议地址是32位的IPv4地址或者128位的IPv6地址与16位的TCP或UDP端口号的组合。

```
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);
```

```
历史上讲述bind函数的手册页面曾说“bind assigns a name to an unnamed socket（bind 函数为一个无名的套接字命名）”。使用“name”一词易于让人混淆，因为它具有诸如foo.bar.com之类域名的涵义。bind函数其实与名字没有任何关系。它只是把一个协议地址赋予一个套接字，至于协议地址的涵义取决于协议本身。
```

第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。对于TCP，调用bind函数可以指定一个端口号，或者指定一个IP地址，也可以两者都指定，还可以都不指定。

* 服务器在启动时捆绑它们的众所周知端口，我们在
