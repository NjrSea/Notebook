# 第4章 基本TCP套接字编程

## 4.1 概述

本章讲解编写一个完整的TCP客户/服务器程序所需要的基本套接字函数。讲解完即将使用的所有基本套接字函数之后，我们将在下一张开发一个客户/服务器程序。 我们将围绕该程序展开本书，并多次对它加以改进。

我们还讲解并发服务器，它是在同时有大量客户的连接到同一服务器上时使用于提供并发性的一种常见Unix技术。每个客户端连接都迫使服务器fork一个新的进程。本章中我们只考虑使用fork实施的每个客户单进程模型，然而当在第26张讨论线程时，我们将考虑称为没客户单线程的另外一种模型。

图4-1给出了在一对TCP客户与服务器进程之间发生的一些典型事件的时间表。服务器首先启动，稍后某个时刻客户端启动，它试图连接到服务器。我们假设客户端给服务器发送一个请求，服务器处理该请求，并且给客户发回一个响应。这个过程一直持续下去，知道客户关闭连接的客户端，从而给服务器发送一个EOF通知为止。服务器接着也关闭连的服务器端，然后结束运行或者等待新的客户连接。

## 4.2 socket函数

为了执行网络I/O，一个进程必须做的第一件事情就是调用socket函数，制定期望的通信协议类型（使用IPv4的TCP、使用IPv6的UDP、Unix域字节流协议等）。

```
#include <sys/socket.h>

int socket(int family, int type, int protocol); /* 返回：若成功则为非负描述符，若出错则为-1 */
```

其中family参数指明协议族，它是图4-2所示的某个常值。该参数也往往被称为协议域。type参数指明套接字类型，它是图4-3中所示的某个常值。porotocol参数应设为图4-4所示的某个协议类型常值，或者设为0，以选择所给定family和type组合的系统默认值。

并非所有套接字family和type的组合都是有效的，图4-5给出了一些有效的组合和对应的真正协议。其中标为“是”的项也是有效的，但是还没有便捷的缩略词。而空白项则是无效组合。

```
你可能还会碰到作为socket函数第一参数的相应的PF_xxx常值，我们在本节末讲解。你也许会碰到AF_LOCAL被代之为AF_UNIX，在第15章中我们再做详细说明。

参数family和type还有其他值。例如4.4BSD支持的family参数值还有AF_NSS和AF_ISO（OSI协议），不过现在很少有人使用这些协议。

Xerox NS协议和OSI协议都实现了对SOCK_SEQPACKET这个type参数值的支持，我们将在9.2节讲解该值在SCTP中的使用。然而TCP是一个字节流协议，仅支持SOCK_STREAM套接字。

Linux支持一个新的套接字类型SOCK_PACKET，它与图2-1中的BPF和DLPI类似，支持对数据链路的访问，具体将在第29张中叙述。

密钥套接字AF_KEY比较新，用于支持基于加密的安全性。跟路由套接字（AF_ROUTE）是内核中路由表的接口这种方式类似，密钥套接字是与内核中密钥表的接口。密钥套接字在第19章中讲解。
```

socket函数在成功时返回一个小的非负整数值，它与文件描述符类似，我们把它称为套接字描述符（socket descriptor），简称sockfd。为了得到这个套接字描述符，我们只是制定了协议族和套接字类型。我们并没有制定本地协议地址或远程协议地址。

***对比AF_XXX和PF_XXX***

AF_前缀表示地址族，PF_前缀表示协议族。历史上曾有这样的想法：单个协议族可以支持多个地址族，PF_值用来创建套接字，而AF——值用于套接字地址结构。但实际上，支持多个地址族的协议族从来就未实现过，而且头文件<sys/socket.h>中为一给定协议定义的PF_值总是与此协议的AF_值相等。尽管这种相等关系并不一定永远成立，但若有人试图给已有的协议改变这种约定，则许多现存代码都将崩溃。为与现存代码保持一致，本书中我们仅使用AF_常值，尽管在调用socket时我们可能会碰到PF_值。

```
查看BSD/OS 2.1版本中调用socket的137个程序，可以发现，有143个调用指定AF_值，仅有8个调用指定PF_值。

从历史上说，AF_前缀与PF_前缀具有相似常值集的原因要追溯到4.1cBSD和必我们正讲解的(随4.2BSD出现的）socket函数早些的一个版本。socket函数的4.1cBSD版本采用了四个参数，其中有一个是指向sockproto结构的指针。该结构的第一个成员名为sp_family，它的值是某个PF_值；第二个成员即sp_protocol是一个协议号，与现行socket函数的第三个参数类似。指定协议族的唯一方式就是指定该结构，因此，在这个早期系统结构中，PF_值用来在sockproto结构中指定协议族的结构标签，而AF_值用来在套接字地址结构中指定地址族的结构标签。4.4BSD中仍有sockproto结构，但仅由内核在内部使用。在最初的定义中，对sp_family成员有“protocol family”（协议族）的注释，在4.4BSD源码中已改为“address family”(协议族)了。

让人更弄不清AF_常值和PF_之间区别的是，其中有成员可与socket函数的第一个参数作比较的Berkeley内核数据结构（domain结构的dom_family成员）有这样的注释：它含有AF_值。尽管如此，内核中有些domain结构被初始化为相应的AF_值，而其他的domain结构则被初始化为PF_值。

作为另一个历史注解，4.2BSD中socket函数的手册页面将该函数的第一个参数称为af，并把它的可能取值作为AF_常值列出。

最后，我们指出POSIX规范指定socket函数的第一个参数为PF_值，而AF_值用于套接字地址结构。然而它在addrinfo结构中却只定义了一个族值，即用于调用socket函数，也用于套接字地址结构中。
```

## 4.3 connect函数

TCP客户用connect函数来建立与TCP服务器的连接。

```
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen); /* 若成功则返回0，若出错为-1 */
```

sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小，如3.3节所述。套接字地质结构必须函数服务器的IP地址和端口号。我们已经在图1-5中见过本函数的一个例子。

客户在调用函数connect前不必非得调用bind函数，因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。

如果是tcp套接字，调用connect函数将激发tcp的三路握手过程，而且仅在连接建立成功或出错时才会返回，其中出错返回可能有以下几种情况。

（1）若tcp客户没有收到syn分节的响应，则返回etimedout错误。举例来说，调用connect函数时，4.4bsd内核发送一个syn，若无响应则等待6s后再发送一个，若仍无响应则等待24s后再发送一个。若总共等了75s后仍未收到响应则返回本错误。

有些系统提供对超时值的管理型控制。

（2）若对客户的syn的响应是rst（表示复位），则表明该服务器主机在我们指定的端口上没有进程在等待与之连接(例如服务器进程也许没有在运行).这是一种应错误（hard error），客户一接受到rst就马上返回ECONNREFUSED错误。

rst是tcp在发生错误时发送的一种tcp分节。产生rst的三个条件是：目的地为某端口的syn到达，然而该端口上没有正在监听的服务；tcp想取消一个已有连接；tcp接受到一个根本不错在的连接上的分节。

（3）若客户发出的syn再中间的某个路由器上引发了一个“destination unreachable”ICMP错误，则认为是一种软错误。客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送syn。若在某个规定时间（4.4bsd规定75s）后仍未收到响应，则把保存的消息（即ICMP错误）作为EHOSTUNREACH或ENETUNREACH错误返回给进程。以下两种情形也是有可能的：一是按照本地系统的转发表，根本没有到达远程系统的路径；二是connect调用根本不等待就返回。

```
许多早期系统在收到“目的地不可达”ICMP错误时会不正确地放弃建立连接的尝试。这种做法不正确是因为ICMP错误可能指示某个暂停状态。譬如说，它可能是终究可以修复的某个路由问题引起的。

注意，及时ICMP错误指示目的网络不可达，图A-15中也没有列出ENETUNREACH。网络不可达的错误被认为已过时，应用程序应该把ENETUNREACH和EHOSTUNREACH作为相同的错误对待。
```

我们可以用图1-5所示的简单客户程序来查看这些不同的出错情况。首先指定本地主机(127.0.0.1）,它正在运行对应的时间获取程序，我们观察正常的输出：

为了查看返回响应的另一种格式，我们指定另外一个主机的IP地址：

我们接着指定本地子网（192.168.1/24）上其主机ID并不存在的一个IP地址，也就是说本地子网上没有一个主机ID为100的主机，这样当客户主机发出arp请求（要求那个不存在的主机响应以其硬件地址)时，它将永远收不到arp请求.


我们等到connect函数超时后才得到该错误。留意我们的err_sys函数以直观刻度的字符串消息显示了ETIMEDOUT错误的含义。

下一个例子中我们指定一个没有运行时间获取服务器程序的主机（其实是一个本地路由器）。

服务器立刻响应以一个RST分节。

最后一个例子中我们指定一个因特网中不可到达的IP地址。如果我们用tcpdump观察分组的情况，就会发现6跳以远的路由器反回了主机不可到达的ICMP错误。

跟ETIMEDOUT错误一样，本例中的connect也在等待规定的一段时间之后才返回EHOSTUNREACH错误。

按照TCP状态转换图，connect函数导致当前套接字从CLOSED状态转移到SYN_SENT状态，若成功则再转移到ESTABLISHED状态。若connect失败则该套接字不在可用，必须关闭，我们不能对这样的套接字在此调用connect函数。在图11-10中我们将看到，当循环调用函数connect为给定主机尝试各个IP地址知道有一个成功时，在每次connect失败后，都必须close当前的套接字描述符并重新调用socket。

## 4.4 bind 函数

bind函数把一个本地协议地址赋予一个套接字。对于网际网协议，协议地址是32位的IPv4地址或者128位的IPv6地址与16位的TCP或UDP端口号的组合。

```
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);
```

```
历史上讲述bind函数的手册页面曾说“bind assigns a name to an unnamed socket（bind 函数为一个无名的套接字命名）”。使用“name”一词易于让人混淆，因为它具有诸如foo.bar.com之类域名的涵义。bind函数其实与名字没有任何关系。它只是把一个协议地址赋予一个套接字，至于协议地址的涵义取决于协议本身。
```

第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。对于TCP，调用bind函数可以指定一个端口号，或者指定一个IP地址，也可以两者都指定，还可以都不指定。

* 服务器在启动时捆绑它们的众所周知端口，我们在图1-9已经看到了。如果一个tcp客户端或服务器未曾调用bind捆绑一个端口，当调用connect或listen时，内核就要为响应的套接字选择一个临时接口。让内核来选择临时端口对于TCP客户来说是正常的，除非应用需要一个预留端口；然而对于TCP服务器来说却极其罕见，因为服务器是通过它们的众所周知端口被大家认识的。

```
这个规则的例外是远程过程调用（Remote Procedure Call， RPC）服务器。它们通常就由内核为它们的监听套接字选择一个临时端口，而该端口随后通过RPC端口映射器进行注册。客户在connect之前，必须与端口映射器联系以获取它们的临时端口。这种情况也适用于使用UDP的RPC服务器。
```

* 进程可以把一个特定的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户端，这就为在改套接字上发送的IP数据报指派了源IP地址。对于TCP服务器，这就限定改套接字只接受那些目的地为这个IP地址的客户连接。TCP客户通常不把IP地址捆绑到它的套接字上。当连接套接字时，内核将根据所用外出网络接口来选择源IP，而所用外出接口则取决于到达服务器所需的路径。如果TCP服务器没有把IP地址捆绑到它的套接字上，内核就把客户端发送的SYN的目的IP地址作为服务器的源IP地址。

正如我们所说，调用bind可以指定IP地址或端口，可以两者都指定，也可以都不指定。图4-6汇总了如何根据预期的结果，设置sin_addr和sin_或者sin6_addr和sin6_port的值。

如果指定端口号为0，那么内核就在bind被调用时选择一个临时端口。然而如果指定IP地址为通配地址，那么内核将等到套接字已连接TCP或者已在套接字上发出数据报UDP时才选择一个本地IP地址。

对于IPv4来说，通配地址畅由值INADDR_ANY来指定，其值一般为0。它告知内核去选择IP地址。我们已在图1-9中随如下赋值语句看到过它的使用：

```
struct sockaddr_in servaddr;
servaddr.sin_addr.s_addr = htonl(INADDR_ANY); /* wildcard */
```

如此赋值对IPv4是可行的，因为其IP地址为32位的，可以用一个简单的数字常值表示（本例中为0），对于IPv6，我们就不能这么做了，因为128位的IPv6地址是存放在一个结构中的。为了解决这个问题，我们改写为：

```
struct sockaddr_in6 serv;
serv.sin6_addr = in6addr_any; /* wildcard */
```

系统预先分配in6addr_any变量并将其初始化为常量IN6ADDR_ANY_INIT。头文件<netinet/in.h>中含有in6addr_any的extern声明。

无论是网络字节序还是主机字节序，INADDR_ANY的值都是一样的(为0）,因此使用htonl并非必须。不过既然头文件<netinet/in.h>中定义的所有INADDR_常值都是按照主机字节序定义的，我们应该对任何这些常值使用htonl。

如果让内核来为套接字选择一个临时端口号，那么必须这注意，函数bind并不返回选择的值。实际上，由于bind函数的第二个参数有const限定词，它无法返回所选值。为了得到内核所选择的这个临时端口值，必须调用函数getsockname来返回协议地址。

进程捆绑非通配IP地址到套接字上的常见例子是在多个组织提供Web服务器的主机上。首先，每个组织都有各自的域名，譬如这样的形式：www.organization.com。其次，每个组织的域名都映射到不同的IP地址，不过通常仍在同一个子网上。举例来说，如果子网是198.69.10，那么第一个组织的IP可以是198.69.10.128，第二个组织的可以是198.69.10.129，等等。然后，把所有这些IP地址都定义成单个网络接口的别名（譬如在4.4BSD系统上就是用ifconnfig命令的alias选项来定义），这么一来，IP层将接收所有目的地为任何一个别名地址的外来数据报。最后，为每一个组织启动一个HTTP服务器的副本，每个副本仅仅捆绑相应组织的IP地址。

```
替换上述方法的另一种技术是运行捆绑通配地址的单个服务器。当一个连接到达时，服务器调用getsockname函数获取来自客户端的目的IP地址，它在我们的上述讨论中可以是198.69.10.128、198.69.10.129，等等。服务器然后根据这个客户连接所发网的IP来处理客户的请求。

捆绑非通配IP地址的好处是：把一个给定的目的IP地址解复用到一个给定的服务器进程是由内核完成的。

我们必须仔细区别一个分组的到达接口和该分组的目的IP地址。我们将在8.8节讨论弱端模型和强端系统模型。大多数实现都采用前者，意味着一个分组只要其目的IP地址能够标识目的主机的某个网络接口就行，不必一定是他的到达接口。（这里假设目的主机是多宿主机。）捆绑非通配IP地址只是限定根据目的IP地址确定递送到套接字的数据包，而对于到达接口则未做任何显示，除非主机采用强端系统模型。
```

从bind函数返回的一个常见错误是EADDRINUSE（“Address already in use”，地址已使用）。到7.5节讨论SO_REUSEADDR和SO_REUSEPORT这两个套接字选项时我们再详细说明。

## listen 函数

listen函数仅由TCP服务器调用，它做两件事情.

1) 当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是说，他是一个将调用connect发起连接的客户端套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应该接受指向该套接字的连接请求。根据TCP状态转换图，调用listen导致套接字从CLOSED状态转换到LISTEN状态。

2) 本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。

```
#include <sys/socket.h>

int listen(int sockfd, int backlog); /* 返回：若成功则为0，若出错则为-1 */
```

本函数通常应该在调用socket和bind这两个函数之后，并在调用accept函数之前调用。

为了理解其中的backlog参数，我们必须认识到内核为任何一个给定的监听套接字维护两个队列：

1) 未完成连接队列（incomplete connection queue）,每个这样的SYN分节对应其中一项：已由某个客户端发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态。

2)已完成连接队列（completed connection queue），每个已完成TCP三路握手过程的客户端对应其中一项。这些套接字处于ESTABLISHED状态。

两队列之和不超过backlog

当来自客户端的SYN到达时，TCP在未完成连接队列中创建一个新项，然后响应三路握手的第二分节：服务器的SYN响应，其中捎带对客户SYN的ACK。这一项一直保留在未完成队列中，直到三路握手的第三个分节（客户端对服务器SYN的ACK）到达或者该项超时位置。（Berkeley的实现为这些未完成连接的项设置的超时值为75s).如果三路握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。当进程调用accept时，已完成队列中的队头将返回给进程，或者如果该队列为空，那么进程将被投入睡眠，直到TCP在该队列中放入一项才唤醒它。

关于这两个队列的处理，一下几点需要考虑。

* listen函数的backlog参数曾被规定为这两个队列总和的最大值。

```
backlog 的含义从未有过正式的定义。4.2BSD的手册页面宣称它定位的是：“the maximum length the queue of pending connections may grow to"。许多手册页面甚至POSIX规范也逐字复制该定义，然而该定义并未解释未处理连接是处于SYN——RCVD状态的连接，还是尚未由进程接受的处于ESTABLISHED状态的连接，抑或两者皆可。这个历史性的定义出自追溯到4.2BSD版本的Berkeley的实现，后来被许多其他实现复制。
```

* 源自Berkeley的实现给backlog增设了一个模糊因子（fudge factor）：把它乘以1.5得到为处理队列最大程度。通常指定为5的backlog值实际上允许最多有8项在排队，如图4-10所示。

```
增设模糊因子的理由已无可考证，但是如果我们把backlog看成内核能为某套接字排队的最大已完成连接数，那么增加模糊因子的理由就是把队列中未完成连接也计算在内。
```

* 不要把backlog定义为0，因为不同的实现对此有不同的解释。如果你不想让任何客户端连接到你的监听套接字上，那就关闭该监听套接字。

* 在三路握手正常完成的前提下（也就说没有丢失分节，从而没有重传），未完成连接任何...

* 历史沿用的阳历给出5的backlog，因为这是4.2bsd支持的z这个值在30世纪80年代是足够的，当时繁忙的互联网一天也就处理几百个连接.然而随着WWW的发展，繁忙的服务器一天就要处理几百万个连接，这个偏小的值就根本不够了。繁忙的HTTP服务器必须指定一个大得多的backlog值，而且较新的内核必须支持较大的backlog值。

```
当前的许多系统允许管理员修改backlog的最大值。
```

* 问题是既然backlog值为5往往不够，那么应用进程应该指定多大值的backlog呢？这个问题不好回答。当今的HTTP服务器指定了一个较大的值，但是如果指定值在源代码中是一个常值，那么增长其大小需要重新编译程序。另一个方法是设定一个默认值，不过允许通过命令行选项或环境变量复写默认值。指定一个比内核能够支持的值还要大的backlog也是可以接受的，因为内核应该悄然把所指定的偏大值截成自身支持的最大值，而不返回错误。

我们通过修改listen函数的包裹函数就能够提供解决本问题的一个简单办法。图4-9给出了实际代码。我们允许环境变量LISTQ复写调用者指定的值。

```
void Listen(int fd, int backlog)
{
	char *ptr;

	/* can override 2nd argument with environment variable */
	if ((ptr = getenv("LISTENSQ")) != NULL)
		backlog = atoi(ptr);

	if (listen(fd, backlog) < 0)
		err_sys("listen error");
}
```

* 手册和书本历来声称：固定数目的未处理连接排成队列是为了处理服务器进程在相继的accpet调用之间处于忙状态的情况。这就隐含着如此意义：在这两个队列中，已完成队列通常应该比未完成队列有更多的项。繁忙的web服务器再次表明这是不对的。指定较大backlog值的理由在于：随着客户端SYN分节的到达，未完成连接队列中的项数可能增长，它们等着三路握手的完成。

* 当一个客户端SYN到达时，若这些队列是满的，TCP就忽略该分节，也就是不发送RST。这么做是因为：这种情况是暂时的，客户端TCP将重发SYN，期望不久就能在这些队列中找到可用空间。要是服务器TCP立即响应以一个RST，客户端的connect调用就会立即返回一个错误，强制应用进程处理这种情况，而不是让TCP的正常重传机制来处理。另外，客户端无法区别响应SYN的RST究竟意味着“该端口没有服务器在监听”，还是“该端口有服务器在监听，不过它的队列满了”。

```
有些实现在这些队列满时确实发送RST。由于上述原因，这种做法是不正确的，我们最好忽略其存在的可能性，除非客户端明确要求与这样的服务器交互。处理这种情况的额外代码编写会降低客户端程序的健壮性，在正常的RST情况下（即确实没有服务器在客户请求的端口上监听），也增加了网络的负荷。
```

* 在三路握手完成之后，但在服务器调用accept之前到达的数据应该由服务器tcp排队，最大数据量为相应已连接套接字的接受缓冲区大小。

图4-10给出了图1-16所列出的各种操作系统下，backlog参数区不同值时已排队连接的实际数目。7个操作系统被归纳成5列不同的值，课件对backlog的意义解释是如此多样。

AIX和MacOS有传统的Berkeley算法，Solaris也似乎非常接近该算法，FreeBSD则是backlog值加1.

```
我们已提到过，历史上层把backlog值指定为两个队列之和的最大值。在1996年间，因特网收到一种称为SYN泛滥（SYN flooading）的新型攻击。黑客编写了一个以高速率给受害主机发送SYN的程序，用以装填一个或者多个TCP端口的未完成队列。而且，该程序将每个SYN的源IP地址都制成随机数（称为IP欺骗（IP spoofing）），这样服务器的SYN/ACK就发往不知道什么地方，同时防止受攻击的服务器获悉黑客的真实IP地址。这样，通过伪造SYN状态未完成连接队列，使合法的SYN排不上队，导致针对合法客户的服务被拒绝。有两种处理这种拒绝服务型攻击的常用方法，作了总结。不过这人我们最感兴趣的是回味一下listen的backlog参数的确切含义。它应该指定某个给定套接字上内核为之排队的最大已完成连接数。对于已完成连接数做出限制的目的在于：在监听某个给定套接字的应用程序停止接受连接的时候，防止内核在改套接字上继续接受新的连接请求。如果一个系统实现了这样的解释，那么应用程序就无需仅仅因为服务器进程需要处理大量客户请求或者为了提供对SYN泛滥的防护而指定一个巨大的backlog值了。然而即使在这样的解释下，传统为5的backlog值不够大的情形依然发生。
```

## 4.6 accept 函数

accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠。

```
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); /* 返回：若成功则为非负描述符，若出错则为-1 */
```

参数cliaddr和addrlen用来返回已连接的对端进程的协议地址。addrlen是值-结果参数：调用前，我们将由*addrlen所引用的整数值置为cliaddr所指的套接字地址结构的长度，返回时，该整数值即为由内核存放在该套接字地址结构内的确切字节数。

如果accept成功，那么其返回值是由内核自动生成的一个全新的描述符，代表与所返回客户端的TCP连接。在讨论accpet函数时，我们成它的第一个参数为监听套接字（listensing socket）描述符（由socket创建，随后用作bind和listen的第一个参数的描述符），称它的返回值为已连接套接字（connected socket）描述符。区分这两个套接字非常重要。一个服务器通常仅仅创建一个监听套接字，它在该服务器的生命期内一直存在。内核为每个由服务器进程接受的客户端连接创建一个已连接套接字（也就是说对于它的TCP三路握手过程已经完成）。当服务器完成对某个给定客户端的服务时，相对应的已连接套接字就被关闭。

本函数最多返回三个值：一个即可能是新套接字描述符也可能是出错提示的整数、客户端进程的协议地址以及地址的大小。如果我们对返回客户协议地址不敢兴趣，那么可以把cliaddr和addrlen均置为空指针。

图1-9展示了这些指针。已连接套接字每次都在循环中关闭，但是监听套接字在服务器的整个有效期内都保持开放。我们还看到accept的第二个和第三个参数都是空指针，因为我们队客户的身份不感兴趣。

***例子***

现在，我们通过修改图1-9中所示代码以显示客户端的IP地址和端口号，来看看如何处理accept的值-结果参数，见图4-11.

新的声明

7~8 我们定义了两个新的变量：len，它将成为一个值-结果变量；cliaddr，它将存放客户端的协议地址。

接受连接并显示客户地址

19~23 我们将len初始化为套接字地质结构的大小，将指向cliaddr结构的指针和指向len的指针分别作为accept的第二和第三个参数。调用inet_ntop将套接字地址结构中的32位IP地址转换为一个点分十进制数ASCII字符串，调用ntohs将16位端口号从网络字节序转换为主机字节序。

```
调用sock_ntop来取代inet_ntop将使得我们的服务器更具协议无关性，不过该服务器已经依赖于IPv4了。我们将在图11-13中给出该服务器程序的协议无关版本。
```

运行这个心的服务器程序，然后再同一个主机上连续运行客户端程序两次连接到该服务器，我们得到了来自客户端的如下输出：


```
#include "unp.h"
#include <time.h>

int main(int argc, char **argv)
{
	int listenfd, connfd;
	socklen_t len;
	struct sockaddr_in servaddr, cliaddr;
	char buff[MAXLINE];
	time_t ticks;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
	bzero(&servaddr, sizeof(servadrr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(13); /* daytime server */
	Bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
	Listen(listenfd, LISTENQ);
	for (;;) {
		len = sizeof(cliaddr);
		connfd = Accept(listenfd, (SA *) &cliaddr, &len);
		printf("connection from %s, port %d\n", Inet_ntop(AF_INET, &cliaddr.sin_addr, buff, sizeof(buff)), ntohs(cliaddr.sin_port));

		ticks = time(NULL);
		snprintf(buff, sizeof(buff), "%.24s\r\n", ctime(&ticks));
		Write(connfd, buff, strlen(buff));
		Close(connfd);
	}
}
```

我们首先把服务器主机的地址指定为环回地址（127.0.0.1），然后指定为它自身的IP地址（192.168.1.20）。下面是相应的服务器输出：

注意客户端IP地址的变化。既然我们的时间获取客户端程序不调用bind，而我们在4.4节中说过，这样的客户端由内核根据所用处出接口选定源IP地址。第一个案例中，内核把源IP地址置为环回地址；第二个案例中，内核把源IP地址置为以太网接口的IP地址。从本例子中我们还看到，由Solaris内核选择的临时接口端号先是43388，然后是43389.

最后一点，服务器脚本的shell提示符变为井号，它是超级用户的常用提示符。该服务器必须以超级用户特权运行，以便绑定保留的13号端口。如果没有超级用户特权，调用bind将失败：

bind error： Permission denied

## 4.7 fork和exec函数

在阐述如何编写并发服务器程序之前，我们必须先介绍一下Unix的fork函数。该函数是Unix派生新进程的唯一方法。

```
#include <unistd.h>

pid_t fork(void); /* 返回：在子进程中为0，在父进程中为子进程ID，若出错则为-1 */
```

如果你从前未接触过该函数，那么理解fork最困难之处在于调用它一次，它却返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号；在子进程中又返回一次，返回值为0.因此，返回值本身告知当前进程是子进程还是父进程。

fork在子进程返回0而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用getppid取得父进程的进程ID。相反，父进程可以许多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。

父进程中调用fork之前打开的所以描述符在fork返回之后由子进程分享。我们将看到网络服务器利用了这个特性：父进程调用accept之后调用fork。所接受的已连接套接字随后就在父进程与子进程之间共享。通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字。

fork有两个典型用法。

1）一个进程创建一个自身的副本，这样每个副本都可以在另一个副本执行其他任务的同时处理各自的某个操作。这是网络服务器的典型用法。

2）一个进程想要执行另一个程序。既然创建进程的唯一办法是掉哟呵你个fork，该进程于是首先调用fork创建一个资深的副本，然后其中一个副本调用exec把资深替换成新的程序。这是诸如shell之类程序的典型用法。

存放在硬盘上的可执行文件能够被Unix执行的唯一方法是：由一个现有进程调用6个exec函数中的某一个。exec把当前进程映像替换成新的程序文件，而且该新程序通常从main函数开始执行。进程ID并不改变。我们成调用exec的进程为调用进程（calling process），成新执行的程序为新程序。

```
较老的手册和书本不确切新程序为新程序为新进程（new process），这是错误的，因为其中并没有创建新的进程。
```

这6个exec函数之间的区别在于：（a)待执行的程序文件由文件名（filename)还是由路径名指定；（b)新程序的参数是一一列出还是由一个指针数组来引用；(c)把调用进程的环境传递给新程序还是给新程序指定新的环境。

```
#include <unistd.h>

int execl(const char *pathname, const char *arg0, ... /* (char *) */);

int execv(const char *pathname, char *const *argv[]);

int execle(const char *pathname, const char *arg0, ... /*(char *) 0, const char *arg0, ...);

int execve(const char *pathname, char *const argv[], char *const envp[]);

int execlp(const char *filename, const char *arg0, .../* (char *)0 */);

int execvp(const char *filename, char *const argv[]); /* 均返回： 若成功则不反回，若出错则为-1 */
```

这些函数只在出错时才返回到调用者。否则，控制将被传递给新程序的起始点，通常就是main函数。

这6个函数间的关系如图4-12所示。一般来说，只有execve是内核中的系统调用，其他5个都是调用execve的库函数。

注意下6个函数的下列区别。

1)上面那行的3个函数把新程序的每个参数字符串指定成exec的一个独立参数，并以一个空指针结束可变数量的这些参数。下面那行的3个函数都有一个作为exec参数的argv数组，其中含有指向新程序各个参数字符串的所有指针。

2）左列2个函数指定一个filename参数。exec将使用当前的PATH环境变量把该文件名参数转换为一个路径名。然而一旦这两个函数的failname参数中含有一个斜杠（/)，就不再使用PATH环境变量。右两列4个函数指定一个权限顶的pathname参数。

3)左两列4个函数不显示指定一个环境。相反，它们使用外部变量environ的当前值来构造一个传递给新程序的环境列表。右列2个函数显示指定一个环境列表，其envp指针数组必须以一个空指针结束。


进程在调用exec之前打开着的描述符通常跨exec继续保持打开。我们使用限定词“通常”是因为本默认行为可以使用fcntl设置FD_CLOEXEC描述符标志禁止调。inetd服务器就利用了这个特性，我们将在13.5节讲述这一点。

## 4.8 并发服务器

图4-11中的服务器是一个迭代服务器。对于像时间获取这样的简单服务器来说，这就够了。然而当服务一个客户端请求可能花费较长时间时，我们并不希望整个服务器被单个客户长时间占用，而是希望同时服务多个客户。Unix中编写并发服务器程序最简单的办法就是fork一个子进程来服务每一个客户。图4-13给出了一个典型的并发服务器程序的轮廓。

```
pid_t pid;
int listenfd, connfd;
listenfd = Socket(...);

/*fill in sockaddr_in {} with server's well-known port */

Bind(listenfd, ...);
Listen(listenfd, LISTENQ);

for (;;) {
	connfd = Accept(listenfd, ...); /* probably blocks */
	if ((pid = Fork()) == 0) {
		Close(listenfd); /* child closes listening socket */
		doit(connfd);	 /* process the request */
		Close(connfd);	 /* done with this client */
		exit(0);
	}
	Close(connfd);       /* parent closes connected socket */
}

当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户端（通过已连接套接字connfd），父进程则等待另一个连接（通过监听套接字listenfd）。既然新的客户端由子进程提供服务，父进程就关闭已连接套接字。

图4-13中我们假设由函数doit执行服务客户端所需的所有操作。当该函数返回时，我们在子进程中显示地关闭已连接套接字。这一点并非必须，因为下一个语句是调用exit，而进程终止处理的部分工作就是关闭所有由内核打开的描述符。是否显示调用close只和个人编程风格有关。

我们在2.6节说过，对一个TCP套接字调用close会导致发送一个FIN，随后是正常的TCP连接终止序列。为什么图4-12中父进程对connfd调用close没有终止它与客户端的连接呢？为了便于理解，我们必须知道每个文件或套接字都有一个引用计数。引用计数在文件表项中维护，它是当前打开着的引用该文件或者套接字的描述符的个数。图中socket返回后与listenfd关联的文件表象的引用计数为1.accept返回后与connfd关联的文件表项的引用计数也为1.然而fork返回后，这两个描述符就在父进程与子进程间共享（也就是被复制），因此与这两个套接字相关联的文件表项各自的访问计数值均为2.这么一来，当父进程关闭connfd时，它只是把响应的引用计数值-1.该套接字真正清理和资源释放要等到引用计数到达0时。这会在稍后子进程页管connfd时发生。

我们还可以将图4-13中出现的套接字和连接用图示直观地表达出来。首先，图4-14给出了在服务器阻塞于accept调用且来自客户端的连接请求到达时客户端和服务器的状态。

从accept返回后，我们立即就有图4-15所示状态。连接被内核接受，新的套接字connfd被创建。这是一个已连接套接字，可由此跨连接读写数据。

并发服务器的下一步是调用fork，图给出了从fork返回后的状态。

注意，此时listenfd和connfd这两个描述符都在父进程和子进程之间共享。再下一步是由父进程关闭已连接套接字，由子进程关闭监听套接字，由子进程关闭监听套接字。

这是这两个套接字所期望的最终状态。子进程处理与客户端的连接，父进程则可以在监听套接字上再次调用accept来处理下一个客户端连接。

## close函数

通常的Unix close函数也用来关闭套接字，并终止TCP连接。

close一个TCP套接字的默认行为是把该套接字标记成已关闭，然后激励返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数。然而tcp将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的tcp连接终止序列。

我们将在7.5节介绍的SO_LINGER套接字选项可以用来改变TCP套接字的这种默认行为。我们还将在那节介绍TCP应用进程必须怎么做才能处理确信对端应用进程已收到所有未处理数据。

***描述符引用技术***

在4.8节末尾我们提到过，并发服务器中父进程关闭已连接套接字只是导致响应描述的引用计数减一。既然引用计数值仍大于0，这个close调用并不引发tcp的四分组连接终止序列。对于父进程和子进程共享已连接套接字的并发服务器来说，

如果我们确实想在某个tcp连接上发fin，那么可以改用shutdown已代替close。

我们还得清楚，如果父进程每个由accept返回已连接套接字都不调用close，那么并发服务器将会发生什么。首先，父进程最终将耗尽可用描述符，因为任何进程在任何时刻可以拥有的打开的描述符数通常是限制的。不过更重要的是，没有一个客户端连接会被中断。当子进程关闭已连接套接字时，

### 4.10 getsocketname 和 getpeername函数

这两个函数或者返回某个套接字关联的本地协议地址（getsocketname），或者返回与某个套接字关联的外地协议地址（getpeername）。

```
#include <sys/socket.h>

int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);
int getperrname(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);
```

注意，这两个函数的最后一个参数都是值-结果参数。这就是说，这两个函数都得装填由localaddr或peeraddr指针所指的套接字地址结构。

```
讨论bind时我们提到，使用“name”一次令人误解.这两个函数返回与某个网络的两端中任意一端关联的协议地址，对于IPv4和IPv6来说，这就是IP地址和端口号的组合。这两个函数与域名没有任何联系。
```

需要这两个函数的理由如下所述。

* 在一个没有调用bind的TCP客户上，connect成功返回后，getsockname用于返回由内核赋予该链接的本地IP地址和本地端口号。

* 在以端口号0调用bind（告知内核去选择本地端口号）后，getsockname用于返回由内核赋予的本地端口号。

* getsockname可用于获取某个套接字的地址族，如图所示。

* 在一个以通配IP地址调用调用bind的TCP服务器上，与某个客户端的连接一旦建立，getsockname就可以用于返回由内核赋予连接的本地IP地址。在这样的调用中，套接字描述符参数必须是已连接套接字的描述符，而不是监听套接字的描述符。

* 当一个服务器是由调用过accpet的某个进程通过调用exec执行程序是，它能够获取客户端身份的唯一途径便是调用getpeername。 inetd fork并exec某个TCP服务器程序时就是如此情形，inetd调用accept返回两个值：已连接套接字描述符connfd，这是函数的返回值：客户端的IP地址及端口号，如图中标有“对端地址”的小方框提示。inetd随后调用fork，派生...

略
